[{"id":"a7c41aa1a6dcddf9b4fd172e67e47419","title":"PageHelper简单使用","content":"1. 概述什么是 PageHelper PageHelper 是一个开源的 MyBatis 分页插件，只需在查询前调用静态方法即可对后续 SQL 自动分页，避免手写分页逻辑，实现简单高效。\n适用场景与核心优势\n\n快速接入：兼容 MyBatis 原生和各类 Spring Boot Starter，无需改动已有 Mapper。\n功能完备：支持排序、合理化页码、零页大小等高级特性。\n易于扩展：开放插件属性，可灵活定制分页行为。\n\n2. 快速开始2.1 引入依赖Maven（MyBatis）\n12345&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;  &lt;version&gt;5.4.3&lt;/version&gt;&lt;/dependency&gt;\n\nMaven（Spring Boot Starter）\n12345&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt;\n\n2.2 简易示例12345public PageInfo&lt;User&gt; listUsers(int pageNum, int pageSize) &#123;    PageHelper.startPage(pageNum, pageSize);    List&lt;User&gt; users = userMapper.selectAll();    return new PageInfo&lt;&gt;(users);&#125;\n\n调用该方法即可返回包含分页信息的 PageInfo&lt;User&gt; 对象。\n3. 核心配置3.1 MyBatis 原生配置在 mybatis-config.xml 中加入：\n1234567&lt;plugins&gt;  &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;    &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot; /&gt;    &lt;property name=&quot;reasonable&quot; value=&quot;true&quot; /&gt;    &lt;property name=&quot;supportMethodsArguments&quot; value=&quot;true&quot; /&gt;  &lt;/plugin&gt;&lt;/plugins&gt;\n\n3.2 Spring Boot 自动装配在 application.properties 或 application.yml 中：\n123pagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=true\n\n或（YAML）：\n1234pagehelper:  helperDialect: mysql  reasonable: true  supportMethodsArguments: true\n\n无需手动注册插件，Starter 会自动装配。\n4. 基础用法4.1 使用 PageHelper.startPage在 Service 层调用：\n123PageHelper.startPage(pageNum, pageSize);List&lt;Entity&gt; list = mapper.queryByCondition(cond);PageInfo&lt;Entity&gt; pageInfo = new PageInfo&lt;&gt;(list);\n\n4.2 返回 Page 对象12Page&lt;Entity&gt; page = PageHelper.startPage(pageNum, pageSize).doSelectPage(() -&gt; mapper.queryByCondition(cond));\n\nPage 继承自 ArrayList，并额外包含分页元数据，可直接操作列表。\n5. 进阶功能5.1 方法参数分页开启 supportMethodsArguments 后，可在 Mapper 方法中直接声明：\n1List&lt;User&gt; selectByStatus(int pageNum, int pageSize, int status);\n\nPageHelper 会自动识别参数并分页。\n5.2 排序功能12PageHelper.startPage(pageNum, pageSize).orderBy(&quot;create_time desc, id asc&quot;);\n\n5.3 分页插件属性\nreasonable：页码合理化，小于 1 自动查询第一页，大于最大页自动查询最后一页。\npageSizeZero：设置为 true 时，pageSize=0 将查询全部结果，不做分页。\nparams：自定义分页参数别名，支持将 pageNum、pageSize 改名。\n\n5.4 自定义 count 查询与性能优化\n默认会发起两条 SQL：一条 SELECT COUNT(*)，一条带 LIMIT 的分页查询。\n可通过 count=false 关闭统计总数，或实现自定义 countSql，以及使用缓存减少重复统计。\n\n6. 与 Spring Boot 深度集成\n在主类或配置类上添加：\n\n1@MapperScan(&quot;com.example.mapper&quot;)\n\n\n引入 Starter，无需额外 Bean 注册。\n在 application.yml 中配置分页参数。\n\n示例：\n123456pagehelper:  helperDialect: mysql  reasonable: true  supportMethodsArguments: true  pageSizeZero: false  params: count=countSql\n\n7. 常见问题排查\n多次调用无效：确保 startPage 与目标查询在同一线程、同一方法链内。\n排序无效：检查 orderBy 字段名称与数据库列名是否一致。\n统计慢：大数据量场景下，可关闭统计或优化索引。\n\n8. 最佳实践与性能建议\n合理设置最大 pageSize，避免一次性加载过多数据。\n对频繁分页查询添加缓存，与后台定时刷新机制结合。\n针对大表，确保分页字段（如主键、时间戳）上有索引。\n\n","slug":"PageHelper简单使用","date":"2025-05-14T10:25:03.000Z","categories_index":"笔记","tags_index":"笔记,Mybatis","author_index":"Mesonsaber"},{"id":"b6561191408c9c707cf8132890df3158","title":"Swagger使用笔记","content":"Swagger2Swagger2和Swagger3在使用上有很大不同。\n基础配置引入依赖12345678910111213&lt;!-- Swagger 2 依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt; &lt;!-- 选择适合的版本 --&gt;&lt;/dependency&gt;&lt;!-- Swagger UI 依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt; &lt;!-- 选择适合的版本 --&gt;&lt;/dependency&gt;\n\nSwaggerConfig使用Swagger2需要自己配置一些属性，比如info等等\n123456789101112131415161718@Configuration@EnableSwagger2public class SwaggerConfig &#123;    @Bean    public Docket api() &#123;        return new Docket(DocumentationType.SWAGGER_2)        .select()        .apis(RequestHandlerSelectors.basePackage(&quot;com.example.controller&quot;)) // 扫描 controller 包        .paths(PathSelectors.any()) // 扫描所有路径        .build()        .apiInfo(new ApiInfoBuilder()                 .title(&quot;My API Documentation&quot;) // API 标题                 .description(&quot;API documentation for my Spring Boot application&quot;) // 描述                 .version(&quot;1.0.0&quot;) // 版本号                 .build());    &#125;&#125;\n\n常用注解1. @Api功能：用于标记类，表示该类是一个 Swagger 资源类，即要生成文档的 API 类。\n使用示例：\n12345678import io.swagger.annotations.Api;@Api(value = &quot;User API&quot;, tags = &quot;User Management&quot;)@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123;    // 控制器代码&#125;\n\n\nvalue：描述该资源类的简要信息。\ntags：为该资源类指定标签，可以用于分组显示 API 文档。\n\n2. @ApiOperation功能：用于标记控制器方法，表示该方法是一个 Swagger 资源接口，并生成该接口的文档。\n使用示例：\n1234567import io.swagger.annotations.ApiOperation;@ApiOperation(value = &quot;Get user by ID&quot;, notes = &quot;Provide an ID to look up a specific user from the database&quot;, response = User.class)@GetMapping(&quot;/&#123;id&#125;&quot;)public ResponseEntity&lt;User&gt; getUserById(@PathVariable(&quot;id&quot;) Long id) &#123;    // 业务代码&#125;\n\n\nvalue：方法的简要描述，通常为接口功能名称。\nnotes：接口的详细说明。\nresponse：接口返回的对象类型。\n\n3. @ApiParam功能：用于标记方法参数，生成接口文档时显示该参数的说明信息。\n使用示例：\n123456import io.swagger.annotations.ApiParam;@GetMapping(&quot;/&#123;id&#125;&quot;)public ResponseEntity&lt;User&gt; getUserById(@ApiParam(value = &quot;User ID&quot;, required = true) @PathVariable(&quot;id&quot;) Long id) &#123;    // 业务代码&#125;\n\n\nvalue：描述该参数的含义。\nrequired：是否为必填项，默认为 false。\n\n4. @ApiModel功能：用于标记一个模型类，生成该类的文档描述。\n使用示例：\n12345678910import io.swagger.annotations.ApiModel;@ApiModel(description = &quot;Details about the user&quot;)public class User &#123;    private Long id;    private String name;    private String email;    // Getter and Setter methods&#125;\n\n\ndescription：描述模型的功能或含义。\n\n5. @ApiModelProperty功能：用于标记模型类的属性，生成该属性的文档说明。\n使用示例：\n123456789101112131415import io.swagger.annotations.ApiModelProperty;public class User &#123;    @ApiModelProperty(notes = &quot;The unique ID of the user&quot;, required = true, position = 1)    private Long id;    @ApiModelProperty(notes = &quot;The name of the user&quot;, position = 2)    private String name;    @ApiModelProperty(notes = &quot;The email of the user&quot;, position = 3)    private String email;    // Getter and Setter methods&#125;\n\n\nnotes：描述该字段的详细信息。\nrequired：是否为必填字段。\nposition：字段在模型中的位置，用于排序。\n\n6. @ApiResponse功能：用于标记接口返回的响应信息，可以指定不同的 HTTP 状态码和对应的返回值。\n使用示例：\n123456789101112import io.swagger.annotations.ApiResponse;import io.swagger.annotations.ApiResponses;@ApiResponses(value = &#123;    @ApiResponse(code = 200, message = &quot;Successfully retrieved user&quot;, response = User.class),    @ApiResponse(code = 400, message = &quot;Bad request&quot;),    @ApiResponse(code = 404, message = &quot;User not found&quot;)&#125;)@GetMapping(&quot;/&#123;id&#125;&quot;)public ResponseEntity&lt;User&gt; getUserById(@PathVariable(&quot;id&quot;) Long id) &#123;    // 业务代码&#125;\n\n\ncode：响应状态码。\nmessage：响应描述。\nresponse：响应体的类型。\n\n7. @ApiIgnore功能：用于忽略某个接口或者某个方法，生成文档时不会包含这个接口或方法。\n使用示例：\n1234567import io.swagger.annotations.ApiIgnore;@ApiIgnore@GetMapping(&quot;/ignored&quot;)public String ignoredMethod() &#123;    return &quot;This method is ignored by Swagger&quot;;&#125;\n\n\n该注解可以用于方法或者类上，忽略对应的方法或类的文档生成。\n\n8. @ApiOperation 和 @ApiResponses 配合使用你可以将 @ApiOperation 和 @ApiResponse 配合使用，提供更详细的接口文档。\n使用示例：\n12345678910111213import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiResponse;import io.swagger.annotations.ApiResponses;@ApiOperation(value = &quot;Get user by ID&quot;, notes = &quot;Provide an ID to look up a specific user from the database&quot;)@ApiResponses(value = &#123;    @ApiResponse(code = 200, message = &quot;Successfully retrieved user&quot;, response = User.class),    @ApiResponse(code = 404, message = &quot;User not found&quot;)&#125;)@GetMapping(&quot;/&#123;id&#125;&quot;)public ResponseEntity&lt;User&gt; getUserById(@PathVariable(&quot;id&quot;) Long id) &#123;    // 业务代码&#125;\n\n9. @ApiImplicitParam功能：用于在方法上声明隐式参数，通常用于非路径或查询参数。\n使用示例：\n1234567891011import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;@ApiImplicitParams(&#123;    @ApiImplicitParam(name = &quot;page&quot;, value = &quot;Page number&quot;, required = true, dataType = &quot;int&quot;, paramType = &quot;query&quot;),    @ApiImplicitParam(name = &quot;size&quot;, value = &quot;Page size&quot;, required = true, dataType = &quot;int&quot;, paramType = &quot;query&quot;)&#125;)@GetMapping(&quot;/list&quot;)public List&lt;User&gt; getUsers(@RequestParam int page, @RequestParam int size) &#123;    // 业务代码&#125;\n\n\nname：参数名称。\nvalue：参数描述。\nrequired：是否必填。\ndataType：参数的数据类型。\nparamType：参数的类型（例如，query、path、header）。\n\n最佳实践我给出一个例子，可以对swagger2的使用有个基础的了解\n引入依赖12345678910111213&lt;!-- Swagger 2 依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;io.springfox&lt;/groupId&gt;  &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;  &lt;version&gt;2.9.2&lt;/version&gt; &lt;!-- 选择适合的版本 --&gt;&lt;/dependency&gt;&lt;!-- Swagger UI 依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;io.springfox&lt;/groupId&gt;  &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;  &lt;version&gt;2.9.2&lt;/version&gt; &lt;!-- 选择适合的版本 --&gt;&lt;/dependency&gt;\n\n配置123456789101112131415161718192021222324@Configuration@EnableSwagger2public class SwaggerConfig &#123;    @Bean    public Docket createRestApi() &#123;        return new Docket(DocumentationType.SWAGGER_2)        .apiInfo(apiInfo())        .select()        .apis(RequestHandlerSelectors.basePackage(&quot;com.example.controller&quot;))        .paths(PathSelectors.any()) // 可以设置路径过滤        .build();    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()        .title(&quot;示例项目 API 文档&quot;)        .description(&quot;Spring Boot 2.x + Swagger2 接口文档&quot;)        .version(&quot;1.0.0&quot;)        .contact(new Contact(&quot;你的名字&quot;, &quot;https://example.com&quot;, &quot;email@example.com&quot;))        .build();    &#125;&#125;\n\n注解使用1234567891011121314151617181920212223242526272829303132333435@Api(tags = &quot;用户管理接口&quot;)@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @ApiOperation(value = &quot;根据 ID 查询用户&quot;)    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;path&quot;)    @GetMapping(&quot;/&#123;id&#125;&quot;)    public User getUser(@PathVariable Long id) &#123;        return userService.getUserById(id);    &#125;    @ApiOperation(value = &quot;创建用户&quot;)    @PostMapping    public User createUser(@RequestBody User user) &#123;        return userService.save(user);    &#125;&#125;//模型类@ApiModel(description = &quot;用户对象&quot;)public class User &#123;    @ApiModelProperty(value = &quot;用户ID&quot;, example = &quot;1001&quot;)    private Long id;    @ApiModelProperty(value = &quot;用户名&quot;, example = &quot;Tom&quot;)    private String name;    @ApiModelProperty(value = &quot;邮箱&quot;, example = &quot;tom@example.com&quot;)    private String email;    // getters/setters...&#125;\n\nSwagger3Swagger3包含在Openapi中，所以我们需要引入的依赖是openapi依赖\n基础配置引入依赖1234567&lt;!-- Springdoc OpenAPI UI 依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;    &lt;version&gt;1.6.15&lt;/version&gt; &lt;!-- Spring Boot 2.x 对应版本 --&gt;&lt;/dependency&gt;\n\n123456&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;    &lt;version&gt;2.5.0&lt;/version&gt; &lt;!-- Spring Boot 3.x 对应版本 --&gt;&lt;/dependency&gt;\n\n配置？Swagger3默认不需要自己手动配置SwaggerConfig，除非你需要实现\n\n改变扫描路径（basePackage）\n设置 OpenAPI 标题、描述等信息\n配置分组文档\n\n实例配置1234567891011121314@Configurationpublic class OpenApiConfig &#123;    @Bean    public OpenAPI customOpenAPI() &#123;        return new OpenAPI()            .info(new Info()                .title(&quot;用户系统 API&quot;)                .version(&quot;1.0&quot;)                .description(&quot;用于演示 Springdoc OpenAPI 的使用&quot;)                .contact(new Contact().name(&quot;你的名字&quot;).email(&quot;you@example.com&quot;)));    &#125;&#125;\n\n如果在配置类中使用@OpenAPIDefinition注解，可以直接在注解里修改默认属性，不用写customOpenAPI()方法\n123456789101112131415161718import io.swagger.v3.oas.annotations.OpenAPIDefinition;import io.swagger.v3.oas.annotations.info.Info;import io.swagger.v3.oas.annotations.servers.Server;import org.springframework.context.annotation.Configuration;@Configuration@OpenAPIDefinition(    info = @Info(        title = &quot;用户系统 API&quot;,        version = &quot;1.0&quot;,        description = &quot;这是一个示例项目的接口文档&quot;    ),    servers = @Server(url = &quot;http://localhost:8080&quot;, description = &quot;本地服务器&quot;))public class SwaggerConfig &#123;    // 不需要额外的 OpenAPI Bean，除非你需要更动态的配置&#125;\n\n常用注解1. @OpenAPIDefinition用于全局定义 OpenAPI 文档信息。\n1234@OpenAPIDefinition(    info = @Info(title = &quot;示例 API&quot;, version = &quot;1.0&quot;, description = &quot;用于展示 Swagger3 注解用法&quot;),    servers = @Server(url = &quot;http://localhost:8080&quot;, description = &quot;本地服务&quot;))\n\n\n2. @Operation用于描述单个接口的详细信息（替代 Swagger2 的 @ApiOperation）。\n123456789@Operation(    summary = &quot;获取用户信息&quot;,    description = &quot;通过用户ID获取详细的用户信息&quot;,    operationId = &quot;getUserById&quot;)@GetMapping(&quot;/user/&#123;id&#125;&quot;)public User getUser(@PathVariable Long id) &#123;    return userService.findById(id);&#125;\n\n\n3. @Parameter用于描述接口参数（替代 Swagger2 的 @ApiImplicitParam）。\n12345678@Operation(summary = &quot;查询用户&quot;)@GetMapping(&quot;/user&quot;)public User queryUser(    @Parameter(description = &quot;用户名&quot;, required = true)    @RequestParam String name) &#123;    return userService.findByName(name);&#125;\n\n\n4. @RequestBody用于标注请求体对象，搭配 @io.swagger.v3.oas.annotations.parameters.RequestBody 使用可增强描述。\n12345678@Operation(summary = &quot;创建用户&quot;)@PostMapping(&quot;/user&quot;)public User createUser(    @RequestBody(description = &quot;用户对象&quot;, required = true)    @org.springframework.web.bind.annotation.RequestBody User user) &#123;    return userService.create(user);&#125;\n\n\n5. @Schema用于描述字段或类的结构（替代 Swagger2 的 @ApiModelProperty 和 @ApiModel）。\n123456789@Schema(description = &quot;用户对象&quot;)public class User &#123;    @Schema(description = &quot;用户ID&quot;, example = &quot;1&quot;)    private Long id;    @Schema(description = &quot;用户名&quot;, example = &quot;张三&quot;)    private String name;&#125;\n\n\n6. @Tag用于给 Controller 打标签，方便分类展示。\n123456@Tag(name = &quot;用户接口&quot;, description = &quot;提供用户相关的接口&quot;)@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    ...&#125;\n\n\n✅ 可选补充注解\n\n\n#### 注解名\n#### 说明\n\n\n\n#### @ApiResponse\n#### 单个响应状态描述\n\n\n#### @ApiResponses\n#### 多个响应状态组合\n\n\n#### @Content\n#### 定义请求或响应体类型\n\n\n#### @SecurityRequirement\n#### 定义安全要求，如 JWT 授权等\n\n\n最佳实践123456789101112131415161718192021222324252627282930313233343536@RestController@RequestMapping(&quot;/user&quot;)@Tag(name = &quot;用户模块&quot;, description = &quot;用户管理相关接口&quot;)  // 替代 @Apipublic class UserController &#123;    @Operation(summary = &quot;根据ID查询用户&quot;, description = &quot;提供用户详细信息&quot;)    @ApiResponses(&#123;        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功&quot;),        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户未找到&quot;)    &#125;)    @GetMapping(&quot;/&#123;id&#125;&quot;)    public User getUser(@PathVariable Long id) &#123;        return userService.getUserById(id);    &#125;    @Operation(summary = &quot;创建用户&quot;)    @PostMapping    public User createUser(@RequestBody User user) &#123;        return userService.save(user);    &#125;&#125;//模型类@Schema(description = &quot;用户对象&quot;)public class User &#123;    @Schema(description = &quot;用户ID&quot;, example = &quot;1001&quot;)    private Long id;    @Schema(description = &quot;用户名&quot;, example = &quot;Tom&quot;)    private String name;    @Schema(description = &quot;邮箱&quot;, example = &quot;tom@example.com&quot;)    private String email;&#125;\n\n","slug":"Swagger使用笔记","date":"2025-05-08T02:57:16.000Z","categories_index":"笔记","tags_index":"笔记,Swagger,OpenApi","author_index":"Mesonsaber"},{"id":"ac7b1c384a540317ef37a5647de843f7","title":"Mybatis 笔记","content":"Mybatis练习目标\n\n\n\n\n\n\n\n\n\n\n能够使用映射配置文件实现CRUD操作\n能够使用注解实现CRUD操作\n\n1，配置文件实现CRUD\n如上图所示产品原型，里面包含了品牌数据的 查询 、按条件查询、添加、删除、批量删除、修改 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表：\n\n\n\n\n\n\n\n\n\n\n查询\n查询所有数据\n查询详情\n条件查询\n\n\n添加\n修改\n修改全部字段\n修改动态字段\n\n\n删除\n删除一个\n批量删除\n\n\n\n我们先将必要的环境准备一下。\n1.1  环境准备\n数据库表（tb_brand）及数据准备\n1234567891011121314151617181920212223-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand(    -- id 主键    id           int primary key auto_increment,    -- 品牌名称    brand_name   varchar(20),    -- 企业名称    company_name varchar(20),    -- 排序字段    ordered      int,    -- 描述信息    description  varchar(100),    -- 状态：0：禁用  1：启用    status       int);-- 添加数据insert into tb_brand (brand_name, company_name, ordered, description, status)values (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0),       (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;, 1),       (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1);\n\n实体类 Brand\n在 com.itheima.pojo 包下创建 Brand 实体类。\n12345678910111213141516public class Brand &#123;    // id 主键    private Integer id;    // 品牌名称    private String brandName;    // 企业名称    private String companyName;    // 排序字段    private Integer ordered;    // 描述信息    private String description;    // 状态：0：禁用  1：启用    private Integer status;        //省略 setter and getter。自己写时要补全这部分代码&#125;\n\n编写测试用例\n测试代码需要在 test/java 目录下创建包及测试用例。项目结构如下：\n\n\n安装 MyBatisX 插件\n\nMybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n\n主要功能\n\nXML映射配置文件 和 接口方法 间相互跳转\n根据接口方法生成 statement\n\n\n安装方式\n点击 file ，选择 settings ，就能看到如下图所示界面\n\n\n\n\n\n\n\n\n\n\n\n注意：安装完毕后需要重启IDEA\n\n插件效果\n\n\n红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法，自动生成映射配置文件中的 statement ，如图所示\n\n\n\n\n\n1.2  查询所有数据\n\n如上图所示就页面上展示的数据，而这些数据需要从数据库进行查询。接下来我们就来讲查询所有数据功能，而实现该功能我们分以下步骤进行实现：\n\n编写接口方法：Mapper接口\n\n参数：无\n查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。\n\n\n结果：List\n我们会将查询出来的每一条数据封装成一个 Brand 对象，而多条数据封装多个 Brand 对象，需要将这些对象封装到List集合中返回。\n\n\n执行方法、测试\n\n\n\n\n1.2.1  编写接口方法在 com.itheima.mapper 包写创建名为 BrandMapper 的接口。并在该接口中定义 List&lt;Brand&gt; selectAll() 方法。\n1234567public interface BrandMapper &#123;    /**     * 查询所有     */    List&lt;Brand&gt; selectAll();&#125;\n\n1.2.2  编写SQL语句在 reources 下创建 com/itheima/mapper 目录结构，并在该目录下创建名为 BrandMapper.xml 的映射配置文件\n1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.BrandMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt;        select *        from tb_brand;    &lt;/select&gt;&lt;/mapper&gt;\n\n1.2.3  编写测试方法在 MybatisTest 类中编写测试查询所有的方法\n123456789101112131415161718192021@Testpublic void testSelectAll() throws IOException &#123;    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法    List&lt;Brand&gt; brands = brandMapper.selectAll();    System.out.println(brands);    //5. 释放资源    sqlSession.close();&#125;\n\n\n\n\n\n\n\n\n\n\n注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。\n执行测试方法结果如下：\n\n从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。为什么这样呢？\n这个问题可以通过两种方式进行解决：\n\n给字段起别名\n使用resultMap定义字段和属性的映射关系\n\n1.2.4  起别名解决上述问题从上面结果可以看到 brandName 和 companyName 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在实体类中属性名是 brandName 和 companyName ，而表中的字段名为 brand_name 和 company_name，如下图所示 。那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。\n\n\n我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。\n12345&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt;    select    id, brand_name as brandName, company_name as companyName, ordered, description, status    from tb_brand;&lt;/select&gt;\n\n而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了sql 片段可以提高sql的复用性。\nSQL片段：\n\n将需要复用的SQL片段抽取到 sql 标签中\n123&lt;sql id=&quot;brand_column&quot;&gt;\tid, brand_name as brandName, company_name as companyName, ordered, description, status&lt;/sql&gt;\n\nid属性值是唯一标识，引用时也是通过该值进行引用。\n\n在原sql语句中进行引用\n使用 include 标签引用上述的 SQL 片段，而 refid 指定上述 SQL 片段的id值。\n12345&lt;select id=&quot;selectAll&quot; resultType=&quot;brand&quot;&gt;    select    &lt;include refid=&quot;brand_column&quot; /&gt;    from tb_brand;&lt;/select&gt;\n\n1.2.5  使用resultMap解决上述问题起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。\n那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。\n\n在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系\n123456789101112&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt;    &lt;!--            id：完成主键字段的映射                column：表的列名                property：实体类的属性名            result：完成一般字段的映射                column：表的列名                property：实体类的属性名        --&gt;    &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt;    &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;&lt;/resultMap&gt;\n\n\n\n\n\n\n\n\n\n\n注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。\n\nSQL语句正常编写\n1234&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand;&lt;/select&gt;\n\n1.2.6  小结实体类属性名 和 数据库表列名 不一致，不能自动封装数据\n\n&#x3D;&#x3D;起别名：&#x3D;&#x3D;在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样\n可以定义 片段，提升复用性\n\n\n&#x3D;&#x3D;resultMap：&#x3D;&#x3D;定义 完成不一致的属性名和列名的映射\n\n而我们最终选择使用 resultMap的方式。查询映射配置文件中查询所有的 statement 书写如下：\n12345678910111213141516171819 &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt;     &lt;!--            id：完成主键字段的映射                column：表的列名                property：实体类的属性名            result：完成一般字段的映射                column：表的列名                property：实体类的属性名        --&gt;     &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt;     &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand;&lt;/select&gt;\n\n\n\n1.3  查询详情\n\n有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 查看详情 来进行查询，如上图所示。\n查看详情功能实现步骤：\n\n编写接口方法：Mapper接口\n\n\n\n参数：id\n查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。\n\n结果：Brand\n根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可\n\n\n\n编写SQL语句：SQL映射文件\n\n\n执行方法、进行测试\n\n\n1.3.1  编写接口方法在 BrandMapper 接口中定义根据id查询数据的方法 \n1234/**  * 查看详情：根据Id查询  */Brand selectById(int id);\n\n1.3.2  编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType\n1234&lt;select id=&quot;selectById&quot;  resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand where id = #&#123;id&#125;;&lt;/select&gt;\n\n\n\n\n\n\n\n\n\n\n注意：上述SQL中的 #{id}先这样写，一会我们再详细讲解\n1.3.3  编写测试方法在 test/java 下的 com.itheima.mapper  包下的 MybatisTest类中 定义测试方法\n1234567891011121314151617181920212223 @Testpublic void testSelectById() throws IOException &#123;    //接收参数，该id以后需要传递过来    int id = 1;    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法    Brand brand = brandMapper.selectById(id);    System.out.println(brand);    //5. 释放资源    sqlSession.close();&#125;\n\n执行测试方法结果如下：\n\n\n1.3.4  参数占位符查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 #&#123;id&#125; 最终会被？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。\nmybatis提供了两种参数占位符：\n\n#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 PreparedStatement\n\n${} ：拼接SQL。底层使用的是 Statement，会存在SQL注入问题。如下图将 映射配置文件中的 #{} 替换成 ${} 来看效果\n1234&lt;select id=&quot;selectById&quot;  resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand where id = $&#123;id&#125;;&lt;/select&gt;\n\n重新运行查看结果如下：\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;注意：&#x3D;&#x3D;从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符。\n1.3.5  parameterType使用对于有参数的mapper接口方法，我们在映射配置文件中应该配置 ParameterType 来指定参数类型。只不过该属性都可以省略。如下图：\n1234&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand where id = $&#123;id&#125;;&lt;/select&gt;\n\n1.3.6  SQL语句中特殊字段处理以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值，如下图\n\n\n可以看出报错了，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义\n\n转义字符\n下图的 &amp;lt; 就是 &lt; 的转义字符。\n\n\n\n\n\n\n1.4  多条件查询\n我们经常会遇到如上图所示的多条件查询，将多条件查询的结果展示在下方的数据列表中。而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题\n\n条件表达式\n如何连接\n\n条件字段 企业名称  和 品牌名称 需要进行模糊查询，所以条件应该是：\n\n\n简单的分析后，我们来看功能实现的步骤：\n\n编写接口方法\n\n参数：所有查询条件\n结果：List\n\n\n在映射配置文件中编写SQL语句\n\n编写测试方法并执行\n\n\n1.4.1  编写接口方法在 BrandMapper 接口中定义多条件查询的方法。\n而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现\n\n使用 @Param(&quot;参数名称&quot;) 标记每一个参数，在映射配置文件中就需要使用 #&#123;参数名称&#125; 进行占位\n1List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName,@Param(&quot;brandName&quot;) String brandName);\n\n将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和实体类属性名保持一致。\n1List&lt;Brand&gt; selectByCondition(Brand brand);\n\n将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 #&#123;内容&#125; 时，里面的内容必须和map集合中键的名称一致。\n1List&lt;Brand&gt; selectByCondition(Map map);\n\n1.4.2  编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType\n1234567&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand    where status = #&#123;status&#125;    and company_name like #&#123;companyName&#125;    and brand_name like #&#123;brandName&#125;&lt;/select&gt;\n\n1.4.3  编写测试方法在 test/java 下的 com.itheima.mapper  包下的 MybatisTest类中 定义测试方法\n12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void testSelectByCondition() throws IOException &#123;    //接收参数    int status = 1;    String companyName = &quot;华为&quot;;    String brandName = &quot;华为&quot;;    // 处理参数    companyName = &quot;%&quot; + companyName + &quot;%&quot;;    brandName = &quot;%&quot; + brandName + &quot;%&quot;;    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法\t//方式一 ：接口方法参数使用 @Param 方式调用的方法    //List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName);    //方式二 ：接口方法参数是 实体类对象 方式调用的方法     //封装对象    /* Brand brand = new Brand();        brand.setStatus(status);        brand.setCompanyName(companyName);        brand.setBrandName(brandName);*/        //List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand);        //方式三 ：接口方法参数是 map集合对象 方式调用的方法    Map map = new HashMap();    map.put(&quot;status&quot; , status);    map.put(&quot;companyName&quot;, companyName);    map.put(&quot;brandName&quot; , brandName);    List&lt;Brand&gt; brands = brandMapper.selectByCondition(map);    System.out.println(brands);    //5. 释放资源    sqlSession.close();&#125;\n\n1.4.4  动态SQL上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的\n例如用户只输入 当前状态 时，SQL语句就是\n1select * from tb_brand where status = #&#123;status&#125;\n\n而用户如果只输入企业名称时，SQL语句就是\n1select * from tb_brand where company_name like #&#123;companName&#125;\n\n而用户如果输入了 当前状态 和 企业名称  时，SQL语句又不一样\n1select * from tb_brand where status = #&#123;status&#125; and company_name like #&#123;companName&#125;\n\n针对上述的需要，Mybatis对动态SQL有很强大的支撑：\n\n\n\n\n\n\n\n\n\n\nif\n\nchoose (when, otherwise)\n\ntrim (where, set)\n\nforeach\n\n\n我们先学习 if 标签和 where 标签：\n\nif 标签：条件判断\n\ntest 属性：逻辑表达式\n\n1234567891011121314&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand    where        &lt;if test=&quot;status != null&quot;&gt;            and status = #&#123;status&#125;        &lt;/if&gt;        &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;            and company_name like #&#123;companyName&#125;        &lt;/if&gt;        &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;            and brand_name like #&#123;brandName&#125;        &lt;/if&gt;&lt;/select&gt;\n\n如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。\n执行结果如下：\n\n但是它也存在问题，如果此时给的参数值是\n1234Map map = new HashMap();// map.put(&quot;status&quot; , status);map.put(&quot;companyName&quot;, companyName);map.put(&quot;brandName&quot; , brandName);\n\n拼接的SQL语句就变成了\n1select * from tb_brand where and company_name like ? and brand_name like ?\n\n而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决\n\nwhere 标签\n\n作用：\n替换where关键字\n会动态的去掉第一个条件前的 and \n如果所有的参数没有值则不加where关键字\n\n\n\n123456789101112131415&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand    &lt;where&gt;        &lt;if test=&quot;status != null&quot;&gt;            and status = #&#123;status&#125;        &lt;/if&gt;        &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;            and company_name like #&#123;companyName&#125;        &lt;/if&gt;        &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;            and brand_name like #&#123;brandName&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n\n\n\n\n\n\n\n\n注意：需要给每个条件前都加上 and 关键字。\n\n\n1.5 单个条件（动态SQL）\n\n如上图所示，在查询时只能选择 品牌名称、当前状态、企业名称 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 \n这种需求需要使用到  choose（when，otherwise）标签  实现，  而 choose 标签类似于Java 中的switch语句。\n通过一个案例来使用这些标签\n1.5.1  编写接口方法在 BrandMapper 接口中定义单条件查询的方法。\n123456/**  * 单条件动态查询  * @param brand  * @return  */List&lt;Brand&gt; selectByConditionSingle(Brand brand);\n\n1.5.2  编写SQL语句在 BrandMapper.xml 映射配置文件中编写 statement，使用 resultMap 而不是使用 resultType\n1234567891011121314151617&lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand    &lt;where&gt;        &lt;choose&gt;&lt;!--相当于switch--&gt;            &lt;when test=&quot;status != null&quot;&gt;&lt;!--相当于case--&gt;                status = #&#123;status&#125;            &lt;/when&gt;            &lt;when test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;&lt;!--相当于case--&gt;                company_name like #&#123;companyName&#125;            &lt;/when&gt;            &lt;when test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt;&lt;!--相当于case--&gt;                brand_name like #&#123;brandName&#125;            &lt;/when&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;\n\n1.5.3  编写测试方法在 test/java 下的 com.itheima.mapper  包下的 MybatisTest类中 定义测试方法\n1234567891011121314151617181920212223242526272829303132@Testpublic void testSelectByConditionSingle() throws IOException &#123;    //接收参数    int status = 1;    String companyName = &quot;华为&quot;;    String brandName = &quot;华为&quot;;    // 处理参数    companyName = &quot;%&quot; + companyName + &quot;%&quot;;    brandName = &quot;%&quot; + brandName + &quot;%&quot;;    //封装对象    Brand brand = new Brand();    //brand.setStatus(status);    brand.setCompanyName(companyName);    //brand.setBrandName(brandName);    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法    List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand);    System.out.println(brands);    //5. 释放资源    sqlSession.close();&#125;\n\n执行测试方法结果如下：\n\n\n1.6  添加数据\n\n如上图是我们平时在添加数据时展示的页面，而我们在该页面输入想要的数据后添加 提交 按钮，就会将这些数据添加到数据库中。接下来我们就来实现添加数据的操作。\n\n编写接口方法\n\n\n参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 &#x3D;&#x3D;自动增长&#x3D;&#x3D; 生成的。\n\n编写SQL语句\n\n\n编写测试方法并执行\n\n\n明确了该功能实现的步骤后，接下来我们进行具体的操作。\n1.6.1  编写接口方法在 BrandMapper 接口中定义添加方法。\n1234 /**   * 添加   */void add(Brand brand);\n\n1.6.2  编写SQL语句在 BrandMapper.xml 映射配置文件中编写添加数据的 statement\n1234&lt;insert id=&quot;add&quot;&gt;    insert into tb_brand (brand_name, company_name, ordered, description, status)    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);&lt;/insert&gt;\n\n1.6.3  编写测试方法在 test/java 下的 com.itheima.mapper  包下的 MybatisTest类中 定义测试方法\n123456789101112131415161718192021222324252627282930313233@Testpublic void testAdd() throws IOException &#123;    //接收参数    int status = 1;    String companyName = &quot;波导手机&quot;;    String brandName = &quot;波导&quot;;    String description = &quot;手机中的战斗机&quot;;    int ordered = 100;    //封装对象    Brand brand = new Brand();    brand.setStatus(status);    brand.setCompanyName(companyName);    brand.setBrandName(brandName);    brand.setDescription(description);    brand.setOrdered(ordered);    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法    brandMapper.add(brand);    //提交事务    sqlSession.commit();    //5. 释放资源    sqlSession.close();&#125;\n\n执行结果如下：\n\n1.6.4  添加-主键返回在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。\n比如：添加订单和订单项，如下图就是京东上的订单\n\n\n订单数据存储在订单表中，订单项存储在订单项表中。\n\n添加订单数据\n\n\n添加订单项数据，订单项中需要设置所属订单的id\n\n\n明白了什么时候 主键返回 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。\n我们将上面添加品牌数据的案例中映射配置文件里 statement 进行修改，如下\n1234&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into tb_brand (brand_name, company_name, ordered, description, status)    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);&lt;/insert&gt;\n\n\n\n\n\n\n\n\n\n\n在 insert 标签上添加如下属性：\n\nuseGeneratedKeys：是够获取自动增长的主键值。true表示获取\nkeyProperty  ：指定将获取到的主键值封装到哪儿个属性里\n\n1.7  修改\n\n如图所示是修改页面，用户在该页面书写需要修改的数据，点击 提交 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪儿个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据。\n接下来我们就具体来实现\n1.7.1  编写接口方法在 BrandMapper 接口中定义修改方法。\n1234 /**   * 修改   */void update(Brand brand);\n\n\n\n\n\n\n\n\n\n\n上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。\n1.7.2  编写SQL语句在 BrandMapper.xml 映射配置文件中编写修改数据的 statement。\n123456789101112131415161718192021&lt;update id=&quot;update&quot;&gt;    update tb_brand    &lt;set&gt;        &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt;            brand_name = #&#123;brandName&#125;,        &lt;/if&gt;        &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27;&quot;&gt;            company_name = #&#123;companyName&#125;,        &lt;/if&gt;        &lt;if test=&quot;ordered != null&quot;&gt;            ordered = #&#123;ordered&#125;,        &lt;/if&gt;        &lt;if test=&quot;description != null and description != &#x27;&#x27;&quot;&gt;            description = #&#123;description&#125;,        &lt;/if&gt;        &lt;if test=&quot;status != null&quot;&gt;            status = #&#123;status&#125;        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;;&lt;/update&gt;\n\n\n\n\n\n\n\n\n\n\nset 标签可以用于动态包含需要更新的列，忽略其它不更新的列。\n1.7.3  编写测试方法在 test/java 下的 com.itheima.mapper  包下的 MybatisTest类中 定义测试方法\n123456789101112131415161718192021222324252627282930313233343536@Testpublic void testUpdate() throws IOException &#123;    //接收参数    int status = 0;    String companyName = &quot;波导手机&quot;;    String brandName = &quot;波导&quot;;    String description = &quot;波导手机,手机中的战斗机&quot;;    int ordered = 200;    int id = 6;    //封装对象    Brand brand = new Brand();    brand.setStatus(status);    //        brand.setCompanyName(companyName);    //        brand.setBrandName(brandName);    //        brand.setDescription(description);    //        brand.setOrdered(ordered);    brand.setId(id);    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //SqlSession sqlSession = sqlSessionFactory.openSession(true);    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法    int count = brandMapper.update(brand);    System.out.println(count);    //提交事务    sqlSession.commit();    //5. 释放资源    sqlSession.close();&#125;\n\n执行测试方法结果如下：\n\n从结果中SQL语句可以看出，只修改了 status  字段值，因为我们给的数据中只给Brand实体对象的 status 属性设置值了。这就是 set 标签的作用。\n1.8  删除一行数据\n如上图所示，每行数据后面都有一个 删除 按钮，当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。\n接下来就来实现该功能。\n1.8.1  编写接口方法在 BrandMapper 接口中定义根据id删除方法。\n1234/**  * 根据id删除  */void deleteById(int id);\n\n1.8.2  编写SQL语句在 BrandMapper.xml 映射配置文件中编写删除一行数据的 statement\n123&lt;delete id=&quot;deleteById&quot;&gt;    delete from tb_brand where id = #&#123;id&#125;;&lt;/delete&gt;\n\n1.8.3  编写测试方法在 test/java 下的 com.itheima.mapper  包下的 MybatisTest类中 定义测试方法\n123456789101112131415161718192021 @Testpublic void testDeleteById() throws IOException &#123;    //接收参数    int id = 6;    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //SqlSession sqlSession = sqlSessionFactory.openSession(true);    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法    brandMapper.deleteById(id);    //提交事务    sqlSession.commit();    //5. 释放资源    sqlSession.close();&#125;\n\n运行过程只要没报错，直接到数据库查询数据是否还存在。\n1.9  批量删除\n\n\n\n如上图所示，用户可以选择多条数据，然后点击上面的 删除 按钮，就会删除数据库中对应的多行数据。\n1.9.1  编写接口方法在 BrandMapper 接口中定义删除多行数据的方法。\n1234/**  * 批量删除  */void deleteByIds(int[] ids);\n\n\n\n\n\n\n\n\n\n\n参数是一个数组，数组中存储的是多条数据的id\n1.9.2  编写SQL语句在 BrandMapper.xml 映射配置文件中编写删除多条数据的 statement。\n编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 foreach 标签供我们使用\nforeach 标签\n用来迭代任何可迭代的对象（如数组，集合）。\n\ncollection 属性：\nmybatis会将数组参数，封装为一个Map集合。\n默认：array &#x3D; 数组\n使用@Param注解改变map集合的默认key的名称\n\n\n\n\nitem 属性：本次迭代获取到的元素。\nseparator 属性：集合项迭代之间的分隔符。foreach 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。\nopen 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次\nclose 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次\n\n12345678&lt;delete id=&quot;deleteByIds&quot;&gt;    delete from tb_brand where id    in    &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;    ;&lt;/delete&gt;\n\n\n\n\n\n\n\n\n\n\n假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是：\n1delete from tb_brand where id in (1,2,3);\n1.9.3  编写测试方法在 test/java 下的 com.itheima.mapper  包下的 MybatisTest类中 定义测试方法\n123456789101112131415161718192021@Testpublic void testDeleteByIds() throws IOException &#123;    //接收参数    int[] ids = &#123;5,7,8&#125;;    //1. 获取SqlSessionFactory    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //2. 获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession();    //SqlSession sqlSession = sqlSessionFactory.openSession(true);    //3. 获取Mapper接口的代理对象    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);    //4. 执行方法    brandMapper.deleteByIds(ids);    //提交事务    sqlSession.commit();    //5. 释放资源    sqlSession.close();&#125;\n\n1.10  Mybatis参数传递Mybatis 接口方法中可以接收各种各样的参数，如下：\n\n多个参数\n单个参数：单个参数又可以是如下类型\nPOJO 类型\nMap 集合类型\nCollection 集合类型\nList 集合类型\nArray 类型\n其他类型\n\n\n\n1.10.1  多个参数如下面的代码，就是接收两个参数，而接收多个参数需要使用 @Param 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。\n1User select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password);\n\n1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;username&#125;    \tand password=#&#123;password&#125;&lt;/select&gt;\n\n我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 @Param 注解时有以下命名规则：\n\n以 arg 开头  ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：\n\n\n\n\n\n\n\n\n\nmap.put(“arg0”，参数值1);\nmap.put(“arg1”，参数值2);\n\n以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：\n\n\n\n\n\n\n\n\n\nmap.put(“param1”，参数值1);\nmap.put(“param2”，参数值2);\n\n\n代码验证：\n\n在 UserMapper 接口中定义如下方法\n1User select(String username,String password);\n\n在 UserMapper.xml 映射配置文件中定义SQL\n1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;arg0&#125;    \tand password=#&#123;arg1&#125;&lt;/select&gt;\n\n或者\n1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;param1&#125;    \tand password=#&#123;param2&#125;&lt;/select&gt;\n\n运行代码结果如下\n\n\n在映射配合文件的SQL语句中使用用 arg 开头的和 param 书写，代码的可读性会变的特别差，此时可以使用 @Param 注解。\n\n\n在接口方法参数上使用 @Param 注解，Mybatis 会将 arg 开头的键名替换为对应注解的属性值。\n代码验证：\n\n在 UserMapper 接口中定义如下方法，在 username 参数前加上 @Param 注解\n1User select(@Param(&quot;username&quot;) String username, String password);\n\nMybatis 在封装 Map 集合时，键名就会变成如下：\n\n\n\n\n\n\n\n\n\nmap.put(“username”，参数值1);\nmap.put(“arg1”，参数值2);\nmap.put(“param1”，参数值1);\nmap.put(“param2”，参数值2);\n\n在 UserMapper.xml 映射配置文件中定义SQL\n1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;username&#125;    \tand password=#&#123;param2&#125;&lt;/select&gt;\n\n运行程序结果没有报错。而如果将 #&#123;&#125; 中的 username 还是写成  arg0 \n1234567&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;arg0&#125;    \tand password=#&#123;param2&#125;&lt;/select&gt;\n\n运行程序则可以看到错误\n\n\n\n&#x3D;&#x3D;结论：以后接口参数是多个时，在每个参数上都使用 @Param 注解。这样代码的可读性更高。&#x3D;&#x3D;\n1.10.2  单个参数\nPOJO 类型\n直接使用。要求 属性名 和 参数占位符名称 一致\n\nMap 集合类型\n直接使用。要求 map集合的键名 和 参数占位符名称 一致\n\nCollection 集合类型\nMybatis 会将集合封装到 map 集合中，如下：\n\n\n\n\n\n\n\n\n\nmap.put(“arg0”，collection集合);\nmap.put(“collection”，collection集合;\n&#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D;\n\nList 集合类型\nMybatis 会将集合封装到 map 集合中，如下：\n\n\n\n\n\n\n\n\n\nmap.put(“arg0”，list集合);\nmap.put(“collection”，list集合);\nmap.put(“list”，list集合);\n&#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D;\n\nArray 类型\nMybatis 会将集合封装到 map 集合中，如下：\n\n\n\n\n\n\n\n\n\nmap.put(“arg0”，数组);\nmap.put(“array”，数组);\n&#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D;\n\n其他类型\n比如int类型，参数占位符名称 叫什么都可以。尽量做到见名知意\n\n\n2，注解实现CRUD使用注解开发会比配置文件开发更加方便。如下就是使用注解进行开发\n12@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)public User select(int id);\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;注意：&#x3D;&#x3D;\n\n注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 statement\n\nMybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：\n\n查询 ：@Select\n添加 ：@Insert\n修改 ：@Update\n删除 ：@Delete\n\n接下来我们做一个案例来使用 Mybatis 的注解开发\n代码实现：\n\n将之前案例中 UserMapper.xml 中的 根据id查询数据 的 statement 注释掉\n\n\n在 UserMapper 接口的 selectById 方法上添加注解\n\n\n运行测试程序也能正常查询到数据\n\n\n我们课程上只演示这一个查询的注解开发，其他的同学们下来可以自己实现，都是比较简单。\n&#x3D;&#x3D;注意：&#x3D;&#x3D;在官方文档中 入门 中有这样的一段话：\n\n所以，&#x3D;&#x3D;注解完成简单功能，配置文件完成复杂功能。&#x3D;&#x3D;\n而我们之前写的动态 SQL 就是复杂的功能，如果用注解使用的话，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下：\n\n\n上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。\n","slug":"Mybatis-笔记","date":"2025-04-20T11:56:00.000Z","categories_index":"笔记","tags_index":"笔记,Mybatis","author_index":"Mesonsaber"},{"id":"b3e2f99cc30fff3cb39b2aeb3491e62b","title":"基于 Maven 的 Lombok 基本使用","content":"lombok介绍Lombok 是一个 Java 库，通过注解的方式自动生成常见的样板代码（如 getter、setter、构造函数、toString、equals、hashCode 等），从而提高代码的可读性和开发效率。\n✅  Lombok基本使用引入依赖在pom.xml文件中引入依赖\n1234567&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.24&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;\n\n使用常见注解@Getter 和 @Setter自动生成字段的 getter 和 setter 方法。\n1234567import lombok.Getter;import lombok.Setter;public class User &#123;    @Getter @Setter    private String name;&#125;\n\n也可以直接放在类上，表示对所有字段生效：\n123456789import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User &#123;    private String name;    private int age;&#125;\n\n@ToString自动生成 toString() 方法。\n1234567import lombok.ToString;@ToStringpublic class User &#123;    private String name;    private int age;&#125;\n\n@EqualsAndHashCode自动生成 equals() 和 hashCode() 方法。\n1234567import lombok.EqualsAndHashCode;@EqualsAndHashCodepublic class User &#123;    private String name;    private int age;&#125;\n\n@NoArgsConstructor、@AllArgsConstructor 和 @RequiredArgsConstructor\n@NoArgsConstructor：生成无参构造函数。\n@AllArgsConstructor：生成包含所有字段的构造函数。\n@RequiredArgsConstructor：生成包含 final 字段和带有 @NonNull 注解字段的构造函数。\n\n1234567891011import lombok.NoArgsConstructor;import lombok.AllArgsConstructor;import lombok.RequiredArgsConstructor;@NoArgsConstructor@AllArgsConstructor@RequiredArgsConstructorpublic class User &#123;    private String name;    private int age;&#125;\n\n@Data组合注解，等同于同时使用 @Getter、@Setter、@ToString、@EqualsAndHashCode 和 @RequiredArgsConstructor。\n1234567import lombok.Data;@Datapublic class User &#123;    private String name;    private int age;&#125;\n\n@Builder实现建造者模式，提供流式 API 来构建对象。\n1234567import lombok.Builder;@Builderpublic class User &#123;    private String name;    private int age;&#125;\n\n使用：\n1234User user = User.builder().name(&quot;Alice&quot;).age(30).build();\n\n@Slf4j（日志）自动生成 log 对象，简化日志记录。\n12345678import lombok.extern.slf4j.Slf4j;@Slf4jpublic class UserService &#123;    public void saveUser(User user) &#123;        log.info(&quot;Saving user: &#123;&#125;&quot;, user);    &#125;&#125;\n\n📚  参考资料\nLombok 官方文档\nLombok 使用教程（犬小哈教程）\nLombok 注解精讲（CSDN）\n\n","slug":"基于-Maven-的-Lombok-基本使用","date":"2025-04-15T14:14:46.000Z","categories_index":"笔记","tags_index":"笔记,SpringBoot,Maven","author_index":"Mesonsaber"},{"id":"931902b40e7b49ead6194ab4ea55b9d1","title":"SpringBoot自动装配原理","content":"引入SpringBoot进一步简化了web应用开发步骤，其中一个很重要的核心概念就是自动装配，什么是自动装配？自动装配都做了些什么？\n自动装配概述以往我们使用Servlet+Tomcat做web开发时，往往需要自己再xml配置文件中配置一大堆东西，而且往往项目越大，需要配置的东西就越多，这不仅非常繁琐，而且还拖慢了开发周期，自动装配的出现就是为了简化开发过程中的前期配置准备，让程序员更专注于业务的开发和实现。\n自动装配核心理解12345678@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\n\n@SpringBootApplication在SpringBoot的入口类中，存在这样一个注解，我们接下来就从它来剖析一下自动配置的原理。\n进入注解的源码中，我们发现其有两个重要的注解\n12@SpringBootConfiguration@EnableAutoConfiguration\n\n@SpringBootConfiguration进入源码发现它只是被定义为了一个Spring注解，所以我们对它的探究就到这。\n1234567891011@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@Indexedpublic @interface SpringBootConfiguration &#123;    @AliasFor(        annotation = Configuration.class    )    boolean proxyBeanMethods() default true;&#125;\n\n@EnableAutoConfiguration观察注解名可以知道这应该是一个启用自动配置的注解\n进入它的源码，我们发现它有两个重要的注解\n12@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)\n\n@AutoConfigurationPackage从注解名我们可以先了解到，它是自动配置包注解。\n进入源码发现，它有一个重要注解\n1@Import(&#123;AutoConfigurationPackages.Registrar.class&#125;)\n\n@Import({AutoConfigurationPackages.Registrar.class})查看源码可以发现，它其中的Registrar静态类是关键，通过AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]))方法注册了某些东西，我们继续深入。\n123456789101112static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;    Registrar() &#123;    &#125;    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;        AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]));    &#125;    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;        return Collections.singleton(new PackageImports(metadata));    &#125;&#125;\n\n我们找到了PackageImports的构造函数，发现它貌似是获得AutoConfigurationPackage注解下的包，然后将添加到了packageNames这个List数组中。最后再回到registerBeanDefinitions方法中将其注册为。\n1AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));\n\n1234567891011121314PackageImports(AnnotationMetadata metadata) &#123;    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));    List&lt;String&gt; packageNames = new ArrayList(Arrays.asList(attributes.getStringArray(&quot;basePackages&quot;)));    for(Class&lt;?&gt; basePackageClass : attributes.getClassArray(&quot;basePackageClasses&quot;)) &#123;        packageNames.add(basePackageClass.getPackage().getName());    &#125;    if (packageNames.isEmpty()) &#123;        packageNames.add(ClassUtils.getPackageName(metadata.getClassName()));    &#125;    this.packageNames = Collections.unmodifiableList(packageNames);&#125;\n\n@Import({AutoConfigurationImportSelector.class})它引入了AutoConfigurationImportSelector这个类，所以接下来我们要探究这个类是做什么的。\n看类名感觉应该是自动配置引用选择器，观察源码。\n找到selectImports(AnnotationMetadata annotationMetadata)方法的实现，我们观察方法实现，发现它通过this.getAutoConfigurationEntry(annotationMetadata)获得了一个自动配置实体，接下来我们来研究一下getAutoConfigurationEntry(annotationMetadata)这个方法。\n12345678public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;if (!this.isEnabled(annotationMetadata)) &#123;    return NO_IMPORTS;&#125; else &#123;    AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125;&#125;\n\n定位到方法实现，发现它使用了this.getAttributes方法来获得传入参数的属性，而this.getAttributes这个方法返回了EnableAutoConfiguration这个注解名，也就是说，只有使用了@EnableAutoConfiguration这个注解的类，才会启用自动配置。\n1234567891011121314151617181920212223242526272829protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;if (!this.isEnabled(annotationMetadata)) &#123;    return EMPTY_ENTRY;&#125; else &#123;    AnnotationAttributes attributes = this.getAttributes(annotationMetadata);    List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);    configurations = this.&lt;String&gt;removeDuplicates(configurations);    Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);    this.checkExcludedClasses(configurations, exclusions);    configurations.removeAll(exclusions);    configurations = this.getConfigurationClassFilter().filter(configurations);    this.fireAutoConfigurationImportEvents(configurations, exclusions);    return new AutoConfigurationEntry(configurations, exclusions);&#125;&#125;    protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) &#123;        String name = this.getAnnotationClass().getName();        AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, true));        Assert.notNull(attributes, () -&gt; &#123;            String var10000 = metadata.getClassName();            return &quot;No auto-configuration attributes found. Is &quot; + var10000 + &quot; annotated with &quot; + ClassUtils.getShortName(name) + &quot;?&quot;;        &#125;);        return attributes;    &#125;    protected Class&lt;?&gt; getAnnotationClass() &#123;        return EnableAutoConfiguration.class;    &#125;\n\n那么到底要自动配置哪些类呢，在哪里可以找到SpringBoot能自动配置的类？我们继续往下看，getCandidateConfigurations()，我们进入这个方法的实现。\n123456protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;    ImportCandidates importCandidates = ImportCandidates.load(this.autoConfigurationAnnotation, this.getBeanClassLoader());    List&lt;String&gt; configurations = importCandidates.getCandidates();    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring/&quot; + this.autoConfigurationAnnotation.getName() + &quot;.imports. If you are using a custom packaging, make sure that file is correct.&quot;);    return configurations;&#125;\n\n\n\n发现它的实现中使用了ImportCandidates.load这样一个方法，我们发现，它是从META-INF/spring/%s.imports这个文件下加载自动配置类的。\n:::info这里需要注意，如果你学过SpringBoot2，就会发现这里有所不同，在SpringBoot2中，是从/META_INF/spring.factories这个文件下加载自动装配类的，而在SpringBoot3中抛弃了这种方法，SpringBoot3使用ImportCandidates.load方法从META-INF/spring/%s.imports加载自动配置类，但是/META_INF/spring.factories这个文件依然存在，只是其中不再包含需要自动配置的类，这样改变有许多好处，在这先不介绍。\n:::\n1234567891011121314public static ImportCandidates load(Class&lt;?&gt; annotation, ClassLoader classLoader) &#123;        Assert.notNull(annotation, &quot;&#x27;annotation&#x27; must not be null&quot;);        ClassLoader classLoaderToUse = decideClassloader(classLoader);        String location = String.format(&quot;META-INF/spring/%s.imports&quot;, annotation.getName());        Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);        List&lt;String&gt; importCandidates = new ArrayList();        while(urls.hasMoreElements()) &#123;            URL url = (URL)urls.nextElement();            importCandidates.addAll(readCandidateConfigurations(url));        &#125;        return new ImportCandidates(importCandidates);&#125;\n\n我们可以打开这个文件看看\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfigurationorg.springframework.boot.autoconfigure.aop.AopAutoConfigurationorg.springframework.boot.autoconfigure.amqp.RabbitAutoConfigurationorg.springframework.boot.autoconfigure.batch.BatchAutoConfigurationorg.springframework.boot.autoconfigure.cache.CacheAutoConfigurationorg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfigurationorg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfigurationorg.springframework.boot.autoconfigure.context.LifecycleAutoConfigurationorg.springframework.boot.autoconfigure.context.MessageSourceAutoConfigurationorg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfigurationorg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfigurationorg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfigurationorg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfigurationorg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.redis.RedisAutoConfigurationorg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfigurationorg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfigurationorg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfigurationorg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchClientAutoConfigurationorg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfigurationorg.springframework.boot.autoconfigure.elasticsearch.ReactiveElasticsearchClientAutoConfigurationorg.springframework.boot.autoconfigure.flyway.FlywayAutoConfigurationorg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfigurationorg.springframework.boot.autoconfigure.graphql.GraphQlAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlReactiveQueryByExampleAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlReactiveQuerydslAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlQueryByExampleAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlQuerydslAutoConfigurationorg.springframework.boot.autoconfigure.graphql.reactive.GraphQlWebFluxAutoConfigurationorg.springframework.boot.autoconfigure.graphql.rsocket.GraphQlRSocketAutoConfigurationorg.springframework.boot.autoconfigure.graphql.rsocket.RSocketGraphQlClientAutoConfigurationorg.springframework.boot.autoconfigure.graphql.security.GraphQlWebFluxSecurityAutoConfigurationorg.springframework.boot.autoconfigure.graphql.security.GraphQlWebMvcSecurityAutoConfigurationorg.springframework.boot.autoconfigure.graphql.servlet.GraphQlWebMvcAutoConfigurationorg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfigurationorg.springframework.boot.autoconfigure.gson.GsonAutoConfigurationorg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfigurationorg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfigurationorg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfigurationorg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfigurationorg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfigurationorg.springframework.boot.autoconfigure.http.client.HttpClientAutoConfigurationorg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfigurationorg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfigurationorg.springframework.boot.autoconfigure.integration.IntegrationAutoConfigurationorg.springframework.boot.autoconfigure.jackson.JacksonAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.JdbcClientAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfigurationorg.springframework.boot.autoconfigure.jersey.JerseyAutoConfigurationorg.springframework.boot.autoconfigure.jms.JmsAutoConfigurationorg.springframework.boot.autoconfigure.jmx.JmxAutoConfigurationorg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfigurationorg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfigurationorg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfigurationorg.springframework.boot.autoconfigure.jooq.JooqAutoConfigurationorg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfigurationorg.springframework.boot.autoconfigure.kafka.KafkaAutoConfigurationorg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfigurationorg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfigurationorg.springframework.boot.autoconfigure.ldap.LdapAutoConfigurationorg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfigurationorg.springframework.boot.autoconfigure.mail.MailSenderAutoConfigurationorg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfigurationorg.springframework.boot.autoconfigure.mongo.MongoAutoConfigurationorg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfigurationorg.springframework.boot.autoconfigure.mustache.MustacheAutoConfigurationorg.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfigurationorg.springframework.boot.autoconfigure.netty.NettyAutoConfigurationorg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfigurationorg.springframework.boot.autoconfigure.pulsar.PulsarAutoConfigurationorg.springframework.boot.autoconfigure.pulsar.PulsarReactiveAutoConfigurationorg.springframework.boot.autoconfigure.quartz.QuartzAutoConfigurationorg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfigurationorg.springframework.boot.autoconfigure.r2dbc.R2dbcProxyAutoConfigurationorg.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfigurationorg.springframework.boot.autoconfigure.reactor.ReactorAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfigurationorg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfigurationorg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfigurationorg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfigurationorg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfigurationorg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfigurationorg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfigurationorg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfigurationorg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfigurationorg.springframework.boot.autoconfigure.session.SessionAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.server.servlet.OAuth2AuthorizationServerAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.server.servlet.OAuth2AuthorizationServerJwtAutoConfigurationorg.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfigurationorg.springframework.boot.autoconfigure.ssl.SslAutoConfigurationorg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfigurationorg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfigurationorg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfigurationorg.springframework.boot.autoconfigure.transaction.TransactionAutoConfigurationorg.springframework.boot.autoconfigure.transaction.TransactionManagerCustomizationAutoConfigurationorg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfigurationorg.springframework.boot.autoconfigure.validation.ValidationAutoConfigurationorg.springframework.boot.autoconfigure.web.client.RestClientAutoConfigurationorg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfigurationorg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfigurationorg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfigurationorg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfigurationorg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfigurationorg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfigurationorg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n\n我们发现它们全都以xxxAutoConfiguration来表示。\n思维导图表示接下来我用思维导图的方式展示一下具体的实现原理\n\n自动配置流程理解SpringBoot自动配置帮我们将所有存在于META-INF/spring/%s.imports的类都配置了，但是并不是我们全都会用上，那么SpringBoot是如何判断哪些是我们需要的，哪些不是呢？\n@Conditional 条件匹配（1）@ConditionalOnClass确保某个类存在才进行自动装配：\n1234@ConditionalOnClass(DataSource.class)@Configurationpublic class DataSourceAutoConfiguration &#123;&#125;\n\n只有当 DataSource.class 存在时，DataSourceAutoConfiguration 才会生效。\n（2）@ConditionalOnMissingBean确保没有自定义 Bean 时，才进行自动装配：\n12345@Bean@ConditionalOnMissingBeanpublic DataSource dataSource() &#123;    return new HikariDataSource();&#125;\n\n如果自己定义了 DataSource，这个 Bean不会被创建。\n（3）@ConditionalOnProperty检查配置文件是否开启某个功能：\n1234@ConditionalOnProperty(name = &quot;spring.datasource.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)@Configurationpublic class DataSourceAutoConfiguration &#123;&#125;\n\n如果 spring.datasource.enabled=true，则启用自动配置。\n通过一系列判断，SpringBoot能够自动选择到底要注册哪些类。\n如何知道哪些类能配置我们知道SpringBoot会从META-INF/spring/%s.imports文件中自动配置类，而这个文件中类的名称都是xxxxAutoConfiguration，比如常见的SessionAutoConfiguration\n1234567@AutoConfiguration(    after = &#123;DataSourceAutoConfiguration.class, HazelcastAutoConfiguration.class, JdbcTemplateAutoConfiguration.class, MongoDataAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class, RedisAutoConfiguration.class, RedisReactiveAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class&#125;,    before = &#123;HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class&#125;)@ConditionalOnClass(&#123;Session.class&#125;)@ConditionalOnWebApplication@EnableConfigurationProperties(&#123;ServerProperties.class, SessionProperties.class, WebFluxProperties.class&#125;)\n\n在@EnableConfigurationProperties()注解中的类就是我们能在配置文件中配置的类，比如ServerProperties.class，发现@ConfigurationProperties配置的就是我们在配置文件中写的server.xxxx，这个类的属性就是我们能配置的值，比如port。\n12345678910111213141516171819202122232425@ConfigurationProperties(&quot;server&quot;)public class ServerProperties &#123;    private Integer port;    private InetAddress address;    @NestedConfigurationProperty    private final ErrorProperties error = new ErrorProperties();    private ForwardHeadersStrategy forwardHeadersStrategy;    private String serverHeader;    private DataSize maxHttpRequestHeaderSize = DataSize.ofKilobytes(8L);    private Shutdown shutdown;    @NestedConfigurationProperty    private Ssl ssl;    @NestedConfigurationProperty    private final Compression compression;    private final MimeMappings mimeMappings;    @NestedConfigurationProperty    private final Http2 http2;    private final Servlet servlet;    private final Reactive reactive;    private final Tomcat tomcat;    private final Jetty jetty;    private final Netty netty;    private final Undertow undertow;    .....&#125;\n\n所以我们能发现，哪些类我们能配置其实可以从META-INF/spring/%s.imports文件下各种AutoConfiguration类中找到，我们就不需要去死记硬背了。\n总结以上，我简单介绍了SpringBoot自动装配原理，以及自动配置流程，希望对你有所帮助。\n","slug":"SpringBoot自动装配原理","date":"2025-04-12T08:59:02.000Z","categories_index":"笔记","tags_index":"笔记,SpringBoot","author_index":"Mesonsaber"},{"id":"fbbfb14bbd36bacdc14feb17917b934a","title":"MVC架构","content":"MVC架构我们在开发Javaweb应用时，往往需要使用Servlet来实现业务逻辑，一般情况下，我们会将一个业务的实现逻辑写在一个Servlet类中，它可能会包含数据获取，业务实现，数据输出，假设我们需要编写一个银行转账业务，我们需要在Servlet中编写从数据库获取数据、转账业务实现等等操作，这可能会导致我们在一个Servlet中写了许多代码，而且代码耦合度很高，代码复用性也很差，我们能不能将这些代码拆分成一个个类似Vue中的组件，一个业务逻辑就是一个组件，页面展示是一个组件，数据的控制是一个组件，由此，我们引入了MVC架构模式。\n概述MVC（Model-View-Cotroller）是一种软件架构模式，旨在通过职责分离提升代码的可维护性和扩展性\nMVC三大件Model（模型）\n职责：管理应用程序的数据和业务逻辑。\n处理数据\n封装业务\n\n\n\nView（视图）\n职责：呈现数据并与用户交互\n展示Model的数据\n接收用户操作，不处理逻辑，将操作传递给Controller\n\n\n\nController（控制器）\n职责：协调Model和View\n接收用户输入（HTTP请求），调用对应Model处理\n根据Model结果选择View渲染\n\n\n\nMVC工作流程以用户登录为例：\n\n用户发起登录请求：在浏览器填写表单，点击登录（View层触发）\nController接收请求：解析用户输入。\nModel处理数据：验证用户信息，查询数据库。\n更新View：根据Model返回结果，Controller调用相应View\n\n总结MVC通过分层设计解决了代码混乱的问题，适用于中大型项目或需要长期维护的系统。\n","slug":"MVC架构","date":"2025-04-03T13:47:22.000Z","categories_index":"笔记","tags_index":"笔记,JavaWeb","author_index":"Mesonsaber"},{"id":"c67ce29f34ee2d9d72274617ca0bb9bd","title":"JSP 九大内置对象","content":"JSP九大内置对象哪九个内置对象？\njakarta.servlet.http.HttpServletRequest request\njakarta.servlet.http.HttpServletResponse response\njakarta.servlet.jsp.PageContext pageContext\njakarta.servlet.http.HttpSession session\njava.lang.Throwable exception\njakarta.servlet.ServletContext application\njakarta.servlet.ServletConfig config\njakarta.servlet.jsp.JspWriter out\njava.lang.Object page\n\n都是干嘛的​\t其中，request,pageContext,session,application这四个对象属于作用域对象。\npageContext属于页面作用域，request属于请求作用域，session属于会话作用域，application属于应用作用域。\n四个域的作用范围：pageContext&lt;request&lt;session&lt;application\n四个域都有：setAttribute，getAttribute,removeAttribute方法。\n使用原则：尽量使用范围小的域。\n​\texception属于Throwable对象，负责输出异常信息。\n​\tpage就是this，指当前页面jsp对象。\n​\tout负责文本输出。\n​\tresponse负责响应。\n​\tconfig是Servlet的配置信息。\n","slug":"JSP-九大内置对象","date":"2025-04-02T11:01:56.000Z","categories_index":"笔记","tags_index":"笔记,JavaWeb","author_index":"Mesonsaber"},{"id":"9a1999a60d81f143647e177af12b114b","title":"Cookie理论基础","content":"Cookie的理论基础什么是CookieCookie是由服务器生成的一段纯文本数据，通过HTTP响应头(Set-Cookie)发送给浏览器 (JavaEE中通过new Cookie(name,value)来创建Cookie，使用request.addCookie将Cookie发送到浏览器中) ，并由浏览器存储在本地。随后，每次向同一服务器发起请求时，浏览器都会在HTTP请求头中带上相应的Cookie，从而帮助服务器识别用户和维护会话状态。\n与Session的区别Cookie和Session机制都是为了保存会话状态，Cookie将会话状态保存在浏览器本地，Session将会话状态保存在服务器端。\nJavaEE中使用Cookie在JavaEE中提供有Cookie类，可以对Cookie进行操作。\n1234567891011//创建cookie对象Cookie cookie = new Cookie(&quot;cookie&quot;, &quot;1234&quot;);//设置cookie的存在时间//value&gt;0则保存在硬盘中//value=0则表示删除同名cookie//value&lt;0则cookie不会被存储到硬盘文件中，会放在浏览器运行内存中cookie.setMaxAge(3600);//Change the cookie&#x27;s Path to project&#x27;s context pathcookie.setPath(req.getContextPath());//把cookie传到浏览器resp.addCookie(cookie);\n\n新建的Cookie默认Path是创建Cookie路径的上一级，比如在servlet&#x2F;cookie这个路径创建Cookie，那么默认路径就是&#x2F;servlet，在servlet之下的路径都可以正常获Cookie。\n想要从浏览器中获取Cookie，使用request.getCookies()方法，它返回浏览器中指定路径下的所有Cookie数组。\n12345678Cookie[] cookies = req.getCookies();if (cookies != null) &#123;    for (Cookie cookie : cookies) &#123;         String name = cookie.getName();         String value = cookie.getValue();         System.out.println(name+&quot;=&quot;+value);    &#125;&#125;\n\n\n\n","slug":"Cookie理论基础","date":"2025-03-31T11:43:06.000Z","categories_index":"笔记","tags_index":"笔记","author_index":"Mesonsaber"},{"id":"9fe8d71f2f383c0ca8dbe4af2c600738","title":"不能把 jsp 文件放在 WEB-INF 文件夹中","content":"切记！！JavaWeb 项目中，如果你有 jsp 或者 html 页面展示文件，不能将它放在 WEB-INF 目录中，这样会导致访问路径时出现请求资源不可用的错误！！\n真的要牢记，我就因为这个小小错误，硬控我一个多小时的时间，我哭死。。。\n","slug":"不能把-jsp-文件放在-WEB-INF-文件夹中","date":"2025-03-14T09:21:47.000Z","categories_index":"","tags_index":"笔记,JavaWeb","author_index":"Mesonsaber"},{"id":"fc209dd052d70f296f5bae56a493f474","title":"手写 SpringIOC 框架","content":"为啥要手写 Spring IOC 框架通过自己写一遍框架，可以更好理解 SpringIOC 的底层原理。\n准备阶段创建myspring模块\n引入相关依赖因为需要解析 XML 文件，所以需要用到 dom4j 组件解析 XML 文件\n123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.myspringframework&lt;/groupId&gt;    &lt;artifactId&gt;myspring&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;!--dom4j是一个能够解析 XML 的 java 组件--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;            &lt;version&gt;2.1.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jaxen&lt;/groupId&gt;            &lt;artifactId&gt;jaxen&lt;/artifactId&gt;            &lt;version&gt;1.2.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;&lt;/project&gt;\n\n准备好要管理的 BeanVip类1234567891011121314151617181920212223package com.haishili.myspring.bean;public class Vip &#123;    private String name;    private int age;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Vip&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nOrderDao类12345678package com.haishili.myspring.bean;public class OrderDao &#123;    public void insert() &#123;        System.out.println(&quot;正在保存订单信息&quot;);    &#125;&#125;\n\nOrderService类1234567891011121314package com.haishili.myspring.bean;public class OrderService &#123;    private OrderDao orderDao;    public void setOrderDao(OrderDao orderDao) &#123;        this.orderDao = orderDao;    &#125;    public void save() &#123;        orderDao.insert();    &#125;&#125;\n\n写好配置文件123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans&gt;    &lt;bean id=&quot;vip&quot; class=&quot;com.haishili.myspring.bean.Vip&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;jack&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;19&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;orderDao&quot; class=&quot;com.haishili.myspring.bean.OrderDao&quot;/&gt;    &lt;bean id=&quot;orderService&quot; class=&quot;com.haishili.myspring.bean.OrderService&quot;&gt;        &lt;property name=&quot;orderDao&quot; ref=&quot;orderDao&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n编写阶段编写 ApplicationContext接口ApplicationContext接口提供了一个 getBean 方法用于获取相应 bean 对象，这个方法需要提供具体 Bean 名称。\n12345678package org.myspringframework.core;//MySpring 框架应用上下文接口public interface ApplicationContext &#123;    //根据 Bean 的名称获取对应的 bean 对象    Object getBean(String name);&#125;\n\n编写 ClassPathXmlApplicationContext 类ClassPathXmlApplicationContext类实现 ApplicationContext接口，并重写 getBean 方法。\nClassPathXmlApplicationContext有一个构造方法，在使用 Spring 的时候，我们会在ClassPathXmlApplicationContext构造方法中传入spring.xml这个配置文件的路径，以此让它解析 xml 文件。因此我们在写ClassPathXmlApplicationContext类时也需要接收spring.xml的路径。\n我们知道，在Singleton Bean 中，为了解决循环依赖的问题，Spring使用三重缓存机制，简单的说就是通过提前曝光 Bean 对象，再为属性赋值，这样来解决循环依赖的问题，因为我们也需要让 Bean 提前曝光。\n我们使用 Map 集合存放 Bean 对象，键值对分别是 id和Bean 对象。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package org.myspringframework.core;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;import java.io.InputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;public class ClassPathXmlApplicationContext implements ApplicationContext &#123;    private Map&lt;String, Object&gt; singletons = new HashMap&lt;&gt;();    //接收 xml 配置文件路径并解析配置文件，初始化所有 Bean 对象    public ClassPathXmlApplicationContext(String configLocation) &#123;        try&#123;            //解析 myspring.xml文件，然后实例化 Bean，将 Bean 存放到singletons集合中            //这是 dom4j 解析 XML 文件的核心对象            SAXReader reader = new SAXReader();            //获取一个输入流，指向配置文件            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(configLocation);            //读文件            Document doc = reader.read(is);            //获取所有 bean 标签            List&lt;Node&gt; nodes = doc.selectNodes(&quot;//bean&quot;);            //遍历 bean 标签            for (Node node : nodes) &#123;                //向下转型，使用 Element 接口里的更多方法                Element beanElement = (Element) node;                //获取 id                String id = beanElement.attributeValue(&quot;id&quot;);                //获取 className                String className = beanElement.attributeValue(&quot;class&quot;);                //通过反射机制创建对象，将其放入 Map 集合提前曝光                Class&lt;?&gt; clazz = Class.forName(className);                Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor();                Object instance = declaredConstructor.newInstance();                singletons.put(id, instance);            &#125;            //为属性赋值            nodes.forEach(node -&gt; &#123;                try&#123;                    Element element = (Element) node;                    //获取 id                    String id = element.attributeValue(&quot;id&quot;);                    //获取 className                    String className = element.attributeValue(&quot;class&quot;);                    //获取 class                    Class&lt;?&gt; clazz = Class.forName(className);                    //获取该 bean 标签下所有的 property 标签                    List&lt;Element&gt; propertys = element.elements(&quot;property&quot;);                    //遍历所有的属性标签                    propertys.forEach(property -&gt; &#123;                        try &#123;                            //获取属性名                            String propertyName = property.attributeValue(&quot;name&quot;);                            //获取属性类型                            Field field = clazz.getDeclaredField(propertyName);                            //获取方法名                            String setMethodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);                            //获取方法                            Method method = clazz.getDeclaredMethod(setMethodName, field.getType());                            //获取 value                            String value = property.attributeValue(&quot;value&quot;);                            //获取 ref                            String ref = property.attributeValue(&quot;ref&quot;);                            Object actualValue = null;                            if (ref != null) &#123;                                //表示非简单类型值                                method.invoke(singletons.get(id), singletons.get(ref));                            &#125;                            if(value != null) &#123;                                //表示简单类型值                                //获取属性类型名                                String propertyTypeSimpleName = field.getType().getSimpleName();                                switch (propertyTypeSimpleName) &#123;                                    case &quot;boolean&quot;:                                        actualValue = Boolean.parseBoolean(value);                                        break;                                    case &quot;byte&quot;:                                        actualValue = Byte.parseByte(value);                                        break;                                    case &quot;short&quot;:                                        actualValue = Short.parseShort(value);                                        break;                                    case &quot;int&quot;:                                        actualValue = Integer.parseInt(value);                                        break;                                    case &quot;long&quot;:                                        actualValue = Long.parseLong(value);                                        break;                                    case &quot;float&quot;:                                        actualValue = Float.parseFloat(value);                                        break;                                    case &quot;double&quot;:                                        actualValue = Double.parseDouble(value);                                        break;                                    case &quot;char&quot;:                                        actualValue = value.charAt(0);                                        break;                                    case &quot;String&quot;:                                        actualValue = value;                                &#125;                                //调用方法                                method.invoke(singletons.get(id), actualValue);                            &#125;                        &#125; catch (Exception e ) &#123;                            e.printStackTrace();                        &#125;                    &#125;);                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    @Override    public Object getBean(String beanName) &#123;        return singletons.get(beanName);    &#125;&#125;\n\n\n\n打包发布点击 Lifecycle中的 package 打包为 jar 包\n\n测试12345678910111213141516171819package com.haishili.myspring.test;import com.haishili.myspring.bean.OrderService;import org.junit.Test;import org.myspringframework.core.ApplicationContext;import org.myspringframework.core.ClassPathXmlApplicationContext;public class MySpringTest &#123;    @Test    public void test() &#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;myspring.xml&quot;);        Object vip = applicationContext.getBean(&quot;vip&quot;);        System.out.println(vip);        OrderService orderService = (OrderService) applicationContext.getBean(&quot;orderService&quot;);        orderService.save();    &#125;&#125;\n\n结果\n","slug":"手写-SpringIOC-框架","date":"2024-11-05T14:28:40.000Z","categories_index":"笔记","tags_index":"Spring,Java","author_index":"Mesonsaber"},{"id":"2a1c9c4cc2eeb3e5662886a5a5254cb8","title":"Vue 生命周期","content":"Vue生命周期生命周期概念​\t官方解释\n​\t每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n​\t简单理解\n​\t简单来说就是Vue实例被创建时会经过很多步骤，比如beforeCreate(创建前)，created(完成创建)，beforeMount(挂载前)，mounted(完成挂载)…….\n在这些特殊时期，Vue提供了一些名为生命周期钩子的函数，也就是这些函数会在这些时期执行。你可以在这些函数中添加自己的代码。\n示例代码1234567891011121314151617181920212223&lt;html&gt;  &lt;body&gt;  \t&lt;div id=&quot;root&quot;&gt;        &lt;h1 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎使用VUE&lt;/h1&gt;    &lt;/div&gt;  &lt;/body&gt;    &lt;script&gt;  \tnew Vue(&#123;            el:&#x27;#root&#x27;,            data:&#123;                opacity:1            &#125;,      //当网页元素全部挂在完成时执行mount()中的代码      \t\t\tmounted():&#123;      \t\t\t\t\tsetInterval(()=&gt;&#123;      \t\t\t\t\t\tthis.opacity -=0.01      \t\t\t\t\t\tif(this.opacity &lt;= 0) this.opacity = 1    \t\t\t\t\t\t&#125;,16)    \t\t\t\t&#125;,        &#125;)  &lt;/script&gt;&lt;/html&gt;\n\n\n\n深入生命周期\n\n名词解释挂载阶段​\tInit Events &amp; Lifecycle：初始化：生命周期、事件，但数据处理还没开始。\n​\tbeforeCreate：这时无法通过vm访问到data中的数据、methods中的方法。\n​\tInit injections &amp; reactivity：初始化：数据监测、数据代理。\n​\tcreated：这时可以通过vm访问到data中的数据、methods中配置的方法。\n​\t：此阶段Vue开始解析模板，生成虚拟DOM（内存中），页面还不能显示解析好的内容。\n​\tbeforeMount：这时页面呈现的是未经Vue编译的DOM结构，所有对DOM的操作最终都不奏效。\n​\tCreate vm.$el and replace “el” with it：将内存中的虚拟DOM转为真实DOM插入页面。\n​\tmounted：页面中呈现的是经过Vue编译的DOM，对DOM操作有效（尽可能避免）。至此初始化过程结束，一般在此进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作。\n更新阶段​\tbeforeUpdate：数据发生了更新，此时数据是新的，但是页面是旧的，即：页面尚未和数据保持同步。\t\n​\tVirtual DOM re-render and patch：根据新数据，生成新的虚拟 DOM，随后与旧的虚拟 DOM 进行比较，最终完成页面更新，即：完成了 Model-&gt;View 的更新。\n​\tupdated：此时数据是新的，页面也是新的，即：页面和数据保持同步。\n销毁流程​\tbeforeDestroy：vm中所有的：data、methods、指令等等，都处于可用状态，马上要执行销毁过程，一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。\n​\tTeardow watchers,child components and event listeners：拆除监视者，孩子组件和事件监听者。\n​\tdestroyed：销毁完成。\n重要的钩子\nmounted()\n常在此钩子中进行发送 ajax 请求，启动定时器，绑定自定义事件，订阅消息等操作。\n\nbeforeDestroy()\n\n\n​\t常在此钩子中进行清除定时器，解绑自定义事件，取消订阅消息等操作。\n","slug":"Vue生命周期","date":"2024-04-20T01:09:00.000Z","categories_index":"笔记","tags_index":"JavaScript,Vue","author_index":"Mesonsaber"},{"id":"67e57f0cabb58a64dbb4d43ca7066cb5","title":"Vue 组件化","content":"Vue组件化为什么会有组件\n在传统方法编写一个前端应用时，往往会出现许多为了实现不同功能的文件比如某个区域的 CSS 文件，某个交互效果的 JS 文件，这样复杂的文件导致在使用传统方法编写应用时各个文件的依赖关系混乱，不好维护，而且代码复用率不高。\n\n引入了组件之后，我们将每个部分所用到的文件全部封装到对应的组件，这样即便于管理，也能够更好的复用。\n于是我们把组件定义为实现应用中局部功能代码和资源的集合，\n如何创建组件非单文件组件\n定义组件（创建组件）\n使用 Vue.extend创建，其中 options 和和 new Vue 时传入的 option几乎一样，但也有点区别：\n\nel 不要写，最终所有组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器。\ndata 必须写成函数，避免组件被复用时，数据存在引用关系。\n\n12345678910111213const simple = Vue.extend(&#123;  template:  `  &lt;div&gt;  \t&#123;&#123;a&#125;&#125;  \t&#123;&#123;name&#125;&#125;  &lt;/div&gt;  `,\tdata()&#123;    a:1,    name:&#x27;jack&#x27;  &#125;&#125;)\n\n\n\n注册组件\n\n局部注册：new Vue 的时候传入 components 选项。\n全局注册：Vue.component(‘组件名’,组件)。\n\n\n使用组件（写组件标签）\n&lt;组件名&gt;&lt;&#x2F;组件名&gt;\n\n\n几个注意点：\n\n关于组件名：\n\n​\t一个单词组成：\n​\t\t第一种写法（首字母小写）：school。\n​\t\t第二种写法（首字母大写）：School。\n​\t多个单词组成：\n​\t\t第一种写法（kebab-case 命名）：my-school。\n​\t\t第二种写法（CamelCase 命名）：MySchool（需要使用 Vue 脚手架支持）。\n​\t其他：\n​\t\t(1).组件名不能与 HTML 中已经存在的标签名重复.\n​\t\t(2).可以使用 name 配置项指定组件在开发者工具中的名字。\n\n关于组件标签：\n\n​\t第一种写法：&lt;school&gt;&lt;/school&gt;\n​\t第二种写法：&lt;school/&gt;\n​\t不使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。\n\n一个简写方式：\n\n​\tconst school = Vue.extend(option)可简写成：const school = option。\n单文件组件单文件组件是一个.vue后缀的文件，在其中可以写上 html 结构，js 脚本以及 css 样式。\n1234567891011&lt;template&gt;    &lt;!-- 组件结构 --&gt;&lt;/template&gt;&lt;script&gt;    //组件交互&lt;/script&gt;&lt;style&gt;    /*样式相关*/&lt;/style&gt;\n\n每一个部分的效果都需要单独创建一个 vue 文件，最后使用App.vue将各个 vue 文件汇总起来，使用import语句引入每个 vue 文件\n组件嵌套在一个组件中嵌套另一个组件，它们形成父子关系。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//必须先定义组件        const char = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;角色名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;角色住址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    name: &#x27;谷風　天音&#x27;,                    address: &#x27;東京都&#x27;                &#125;            &#125;        &#125;)        const game = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;游戏名称：&#123;&#123;gameName&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;开发公司：&#123;&#123;compane&#125;&#125;&lt;/h2&gt;                //在父组件的模板中写入子组件的标签                &lt;char&gt;&lt;/char&gt;                &lt;button @click=&quot;showName&quot;&gt;点我&lt;/button&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    gameName: &#x27;天使⭐️騒々 RE-BOOT！&#x27;,                    compane: &#x27;yuzusoft&#x27;                &#125;            &#125;,            methods: &#123;                showName() &#123;                    alert(&quot;死宅真恶心&quot;)                &#125;            &#125;,  \t\t\t\t\t//在组件中注册另一个组件            components:&#123;                char:char            &#125;        &#125;)        new Vue(&#123;            el: &quot;#app&quot;,            data: &#123;                title: &#x27;柚子社&#x27;            &#125;,            components: &#123;              //只需在 vm 中注册一个父组件即可。                game            &#125;,            methods: &#123;            &#125;        &#125;)\n\n\n\n通常可以创建一个 app 组件用来管理所有父组件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const char = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;角色名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;角色住址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    name: &#x27;谷風　天音&#x27;,                    address: &#x27;東京都&#x27;                &#125;            &#125;        &#125;)        const game = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;游戏名称：&#123;&#123;gameName&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;开发公司：&#123;&#123;compane&#125;&#125;&lt;/h2&gt;                &lt;char&gt;&lt;/char&gt;                &lt;button @click=&quot;showName&quot;&gt;点我&lt;/button&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    gameName: &#x27;天使⭐️騒々 RE-BOOT！&#x27;,                    compane: &#x27;yuzusoft&#x27;                &#125;            &#125;,            methods: &#123;                showName() &#123;                    alert(&quot;死宅真恶心&quot;)                &#125;            &#125;,            components:&#123;                char:char            &#125;        &#125;)       const gamer = Vue.extend(&#123;            template:            `            &lt;div&gt;                &lt;h2&gt;玩家名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data()&#123;                return &#123;                    name:&#x27;张三&#x27;                &#125;            &#125;        &#125;)        const app = Vue.extend(&#123;            template:            `            &lt;div&gt;                &lt;gamer&gt;&lt;/gamer&gt;                &lt;game&gt;&lt;/game&gt;            &lt;/div&gt;            `,            components:&#123;                gamer,                game            &#125;        &#125;)              new Vue(&#123;            template:`&lt;app&gt;&lt;/app&gt;`,            el: &quot;#root&quot;,            data: &#123;                title: &#x27;柚子社&#x27;            &#125;,            components: &#123;                app            &#125;,            methods: &#123;            &#125;        &#125;)\n\n\n\nVueComponent其实 Vue 组件就是一个 VUEComponent构造函数，在使用 Vue.extend时生成的。具体 VueComponent 做了什么我们还不去深究。\n每创建一个组件并使用时，都会会有一个全新的 VueComponent。\n在组件配置中，data 函数，methods中的函数，watch 中的函数，computed 中的函数，它们的 this 均是 VueComponent 实例对象。并不是 Vue 实例对象。\n使用Vue脚手架进行单组件开发安装脚手架使用 VueCLI(脚手架)，进行单组件开发是最合适不过的方式，所以接下来我们使用脚手架进行单组件开发。\n安装方法非常简短，在命令行使用npm install -g @vue/cli 或者yarn global add @vue/cli进行安装。\n使用脚手架安装完成后，根据脚手架官网给出的命令创建一个脚手架项目，vue create 项目名称 Vue会给你创建一个已经编写好的 helloworld 项目。\n我们在此基础上进行开发。使用我们也需要对 Vue 给的这个初始项目进行一些了解。\n首先是我们来看一下项目文件夹的结构\n\n从上到下依次是 node_modules(node 组件)，public(公开文件，展示在页面上的比如 html 入口文件)，src(单组件相关文件)，.gitignore（git忽略文件）,babel.config.js（babel配置文件），jsconfig.js（js 配置文件），下面两个都是包管理相关文件，然后是 readme 文件和 vue 配置文件，vue 配置文件可以修改脚手架相关的配置。\n首先我们来看 src 文件夹中的 main.js文件，这时 js 入口文件，一下是其中的代码，可以看到我们会在里面引入 App.vue。这里面比较重要的是render:h=&gt;h(App)这一行，具体这行代码是干什么的可以看注释。\n123456789101112131415161718import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;    //render 可以将模板渲染出来    //因为我们引入的是一个残缺版的 Vue，它无法将模板解析并渲染    //我们使用 render 函数就能吧模板解析出来    // renfer(createElement)&#123;    //     return createElement(&#x27;h1&#x27;,&#x27;hello&#x27;)    // &#125;    //render的完整语法就像上面这样    //使用箭头函数就能简化成下面的格式。    //所以下面这行代码就是讲 App 中的模板渲染出来  render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;)\n\n","slug":"Vue组件化(上)","date":"2024-04-20T01:09:00.000Z","categories_index":"笔记","tags_index":"JavaScript,Vue","author_index":"Mesonsaber"},{"id":"eb51f645a3e7cac33920cb6896f19b9e","title":"从零开始搭建个人博客","content":"搭建个人博客网站步骤为什么要搭建个人博客个人博客可以展示个人的专业知识、技能和经验，让其他人更好的了解你的能力和成就，对于一个程序员来说，个人博客可以是你展示自己学习的东西，可以让自己在简历上有点东西可以写（让 HR 对你刮目相看🤪），而且一个好的博客还能有点装B熟属性😂（是吧是吧）。\n那么怎么来从零开始搭建一个属于自己的博客呢🤔？现在就跟着我一起学习吧🎉！\n开始吧我在Mac上配置环境，如果你是用的是Windows系统，其实也没有什么问题，我会在有区别的地方特别标注😀。\n我分为这几个步骤：\n\n配置环境\n部署到Github\n愉快使用吧\n\n配置环境\n安装 node.js打开你的浏览器搜索node，或者直接点击这里跳转到node.js官网。然后就不用我说了吧，直接凭感觉来点击那个最应该是下载node.js的图标\n\n下载完后打开安装包一直下一步就行.安装完成之后，可以使用命令行来检验是否成功安装\n\n现实版本信息则表示安装成功🎉！\n\n使用npm&#x2F;cnpm 安装 hexo 镜像接下来就是使用cnpm命令来安装hexo镜像了（因为国内使用npm下载很慢，使用使用国内的cnpm源下载会比较快），\n\n所以首先我们安装cnpm\n\n1npm install -g npm --registry=https://registry.npm.taobao.org\n\nwindows系统可以使用（理论应该两个都行）\n1npm i -g cnpm --registry.npm.taobao.org  \n\n进行安装，完成后使用 cnpm -v来查看是否安装成功，显示出版本信息则表示安装成功🎉\n\n然后我们使用cnpm来安装hexo\n1cnpm install -g hexo-cli\n\nwindows系统也是这个命令\n\n\n\n\n\n\n同样也可以使用hexo -v来查看版本信息确定是否安装成功。\n\n初始化博客环境\n新建一个文件夹，用来存放你的博客文件，创建好之后，mac 系统只需要在终端中进到你刚创建的文件夹，然后使用sudo hexo init命令来初始化 hexo 博客，windows 系统需要打开 cmd，然后进入创建好的文件夹，使用 hexo init 来初始化博客，初始化之后，你的文件夹里会出现几个文件及文件夹，这些就是 hexo 生成的，之后如果你的博客出现了什么问题，只需要删除这个文件夹重新开始。\n\n\n\n​\t成功之后使用hexo s在本地预览网页，看看是否成功，\n\n​\t几个常用的 hexo 命令\n​\thexo g生成 hexo 网页，hexo s本地预览网页，hexo d部署到远端，hexo n &quot;文件名&quot;新建博客文件，默认时 markdown 文件\n部署到 Github\n注册 Github，很简单，这里就不细讲了\n\n创建存放博客文档的库\n\n\n库名称必须是你 github 的名字加.github.io\n\n点击 Create repository\n\n\n\n安装 git\n\ngit 是用来把本地 hexo 文件推送到你创建的 github 仓库的\n\n修改 config 文件\n\n修改_config.yml文件\n\n\n这个文件就在你博客文件夹里，repo 地址是你的库地址。\n\n\n\n将博客推送到 github 上\n\n生成 SShKey\n进入到你的博客文件夹，mac 系统在终端使用\n12git config --global user.name &quot;你的 github 名字&quot;git config --global user.eamil &quot;你注册 github 时使用的邮箱地址&quot;\n\n然后再使用这个命令来生成密钥，过程中你需要按三次空格，不需要设置密码。\n1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;\n\n然后使用cat ~/.ssh/id_rsa.pub来查看密钥信息，将显示的内容复制，然后打开 Github-Setting-Keys 页面，新建 SSH key，title 随便写都行，将复制的内容粘贴到Key 文本框中，点击 Add ssh key 就行。\n在 windows 系统上，你需要在你的博客文件夹中使用鼠标右键打开 GitBashHere，再输入跟上面一样的命令就行，有点不同的事你需要自己找到生成的密钥文件，在 生成密钥时会有提示，找到那个文件然后复制里面的内容就行。\n\n推送博客文件\n使用hexo clean清理一下 hexo 文件，hexo g重新生成网页，hexo d推送到远端。成功之后输入你的博客库名字就能访问了。\n\n\n\n\n完成之后​\t几个上面的操作，你应该已经拥有了一个自己的博客网站，当然这个网站还很简陋，你可以找一个喜欢的主题，或者去购买一个域名，这样就可以使用你的域名来访问你的博客网站。\n​\t到这里，这篇如何从零开始搭建自己的博客也就结束了，希望能够帮助到你🥳\n","slug":"从零开始搭建个人博客","date":"2023-11-05T06:50:10.000Z","categories_index":"教程","tags_index":"博客","author_index":"Mesonsaber"},{"id":"70c0c770528c6f3eab2585436d750f40","title":"JavaScript事件对象","content":"事件对象什么是事件对象\n也是一个对象，对象中有事件触发时的相关信息\n例如：鼠标点击事件中，事件对象就存放了鼠标点在了哪个位置等信息\n\n使用场景是什么\n可以判断用户按下哪个键，比如按下回车可以发布留言\n可以判断鼠标点击了哪个元素，从而做出相应的操作\n\n获取事件对象\n语法\n\n在事件绑定的回调函数的第一个参数就是事件对象\n\n1234Element.addEventListener(&#x27;click&#x27;, function(e)&#123;  //e就是事件对象  //可以使用e.方法名/属性名来使用事件对象&#125;)\n\n\n\n\n举个🌰\n\n12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button type=&quot;button&quot;&gt;点击&lt;/button&gt;    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt;    &lt;script&gt;        const input = document.querySelector(&#x27;input&#x27;)        input.addEventListener(&#x27;keyup&#x27;,function(e)&#123;            //使用key属性获取用户按的是哪个键            if(e.key === &#x27;Enter&#x27;)       //判断用户按下的是不是回车键            &#123;                console.log(&#x27;回车键按下&#x27;);            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n效果\n\n\n\n\n\n部分常用属性\n\ntype\n\n获取当前事件类型\n\n\nclientX&#x2F;clientY\n\n获取光标相对于浏览器可见窗口左上角的位置\n1console.log(e.clientX);\n\n\n\n\n\noffsetX&#x2F;offsetY\n\n获取光标相对于当前 DOM 元素左上角的位置\n1console.log(e.offsetX);\n\n\n\n\n\nkey\n\n用户按下的键盘键的值\n\n1console.log(e.key)\n\n\n\n\n\n\n案例实现按下回车发送消息\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;评论回车发布&lt;/title&gt;  &lt;style&gt;    .wrapper &#123;      min-width: 400px;      max-width: 800px;      display: flex;      justify-content: flex-end;    &#125;    .avatar &#123;      width: 48px;      height: 48px;      border-radius: 50%;      overflow: hidden;      background: url(./images/avatar.jpg) no-repeat center / cover;      margin-right: 20px;    &#125;    .wrapper textarea &#123;      outline: none;      border-color: transparent;      resize: none;      background: #f5f5f5;      border-radius: 4px;      flex: 1;      padding: 10px;      transition: all 0.5s;      height: 30px;    &#125;    .wrapper textarea:focus &#123;      border-color: #e4e4e4;      background: #fff;      height: 50px;    &#125;    .wrapper button &#123;      background: #00aeec;      color: #fff;      border: none;      border-radius: 4px;      margin-left: 10px;      width: 70px;      cursor: pointer;    &#125;    .wrapper .total &#123;      margin-right: 80px;      color: #999;      margin-top: 5px;      opacity: 0;      transition: all 0.5s;    &#125;    .list &#123;      min-width: 400px;      max-width: 800px;      display: flex;    &#125;    .list .item &#123;      width: 100%;      display: flex;    &#125;    .list .item .info &#123;      flex: 1;      border-bottom: 1px dashed #e4e4e4;      padding-bottom: 10px;    &#125;    .list .item p &#123;      margin: 0;    &#125;    .list .item .name &#123;      color: #FB7299;      font-size: 14px;      font-weight: bold;    &#125;    .list .item .text &#123;      color: #333;      padding: 10px 0;    &#125;    .list .item .time &#123;      color: #999;      font-size: 12px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;i class=&quot;avatar&quot;&gt;&lt;/i&gt;    &lt;textarea id=&quot;tx&quot; placeholder=&quot;发一条友善的评论&quot; rows=&quot;2&quot; maxlength=&quot;200&quot;&gt;&lt;/textarea&gt;    &lt;button&gt;发布&lt;/button&gt;  &lt;/div&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;span class=&quot;total&quot;&gt;0/200字&lt;/span&gt;  &lt;/div&gt;  &lt;div class=&quot;list&quot;&gt;    &lt;div class=&quot;item&quot; style=&quot;display: none;&quot;&gt;      &lt;i class=&quot;avatar&quot;&gt;&lt;/i&gt;      &lt;div class=&quot;info&quot;&gt;        &lt;p class=&quot;name&quot;&gt;清风徐来&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;大家都辛苦啦，感谢各位大大的努力，能圆满完成真是太好了[笑哭][支持]&lt;/p&gt;        &lt;p class=&quot;time&quot;&gt;2022-10-10 20:29:21&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    const tx = document.querySelector(&#x27;#tx&#x27;)    const total = document.querySelector(&#x27;.total&#x27;)    const item = document.querySelector(&#x27;.item&#x27;)    const text = document.querySelector(&#x27;.text&#x27;)    //当文本域获得焦点，将 total 显示出来    tx.addEventListener(&#x27;focus&#x27;, function()&#123;      total.style.opacity = 1    &#125;)    //失去焦点，就将 total 隐藏    tx.addEventListener(&#x27;blur&#x27;, function()&#123;      total.style.opacity = 0    &#125;)    //检测用户输入    tx.addEventListener(&#x27;input&#x27;, function()&#123;      total.innerHTML=`$&#123;tx.value.length&#125;/200字`    &#125;)    //绑定键盘事件    tx.addEventListener(&#x27;keyup&#x27;,function(e)&#123;      if(e.key===&#x27;Enter&#x27;)      &#123;        if(tx.value.trim()!==&#x27;&#x27;)      //判断输入是否为空        &#123;          item.style.display = &#x27;block&#x27;          text.innerHTML=tx.value        &#125;        tx.value=&#x27;&#x27;   //  清空文本域        total.innerHTML=&#x27;0/200字&#x27;     //恢复字符数量      &#125;          &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n效果\n\n以后就尝试把笔记上传到自己的博客上，不逼一下自己，这些东西容易忘\n","slug":"JavaScript事件对象","date":"2023-10-30T12:00:06.000Z","categories_index":"笔记","tags_index":"JavaScript","author_index":"Mesonsaber"},{"id":"3a720846f06b194cf852fdd1addeae93","title":"KMP匹配算法","content":"KMP匹配算法思路将待查询字符串 searchString 使用一串 next 数组表表示，当与源字符串 sourceString 匹配时，sourceString 不需要移动，只需要将 searchString 移动n位，然后再继续匹配，直到结束。\nnext 数组next 数组的值就是代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果 next[j]&#x3D;k，代表 j 之前的字符串中有最大长度为 k 的相同前缀后缀。\n至于为什么要求next 数组，等我们知道了 next 数组是怎么求的之后，再告诉大家\n那么如何来求 next 数组呢？\n如图：\n\n长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）\n长度为前2个字符的子串aa，最长相同前后缀的长度为1。\n长度为前3个字符的子串aab，最长相同前后缀的长度为0。\n以此类推：长度为前4个字符的子串aaba，最长相同前后缀的长度为1。长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。\n那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：\n可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n理解原理后，我们来用代码实现一下\n首先我们定义 getNext 函数\n1void getNext(char *p,int *next)\n\n\n初始化\n对相应的变量初始化\n\n\n12int j=0;next[0]=0;\t\t\t//第一个字符没有前后缀\n\n\n前后缀不相同情况\n1234567for(int i=0;i&lt;strlen(p);i++)&#123;  while(j&gt;0||p[i]!=p[j])  &#123;    j=next[j-1];  &#125;&#125;\n\n前后缀相同情况\n1234if(p[i]==p[j])&#123;  j++;&#125;\n\n更新 next 数组\n1next[i]=j;\n\n合并代码\n1234567891011121314151617void getNext(char *p,int *next)&#123;  int j=0;\tnext[0]=0;\t\t\t//第一个字符没有前后缀  for(int i=0;i&lt;strlen(p);i++)  &#123;    while(j&gt;0||p[i]!=p[j])    &#123;      j=next[j-1];    &#125;    if(p[i]==p[j])    &#123;      j++;    &#125;    next[i]=j;  &#125;&#125;\n\n相信大家通过代码更加理解了如何求 next 数组了。\n匹配通过以上对 next 数组的理解之后，我们再来KMP 算法是如何匹配的，我们已知，next 数组所代表的就是最大前缀后缀值，也就是说，在失配字符前，有多少个可重复的前缀后缀，这也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j-1] 的位置，也就是在失配字符之前已经重复出现过的前缀的后一个字符）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] &#x3D; k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。\n图例表示\n\n可以看到，当失配时，会跳到当前字符p[j]前一个字符p[j-1]的 next[j-1]值所指的字符，然后接着匹配，直至全部匹配到。\n我们可以简单的用代码表示\n1234567891011121314151617181920int kmp(char *s,char *t)&#123;  int j=0;  for(int i=0;i&lt;strlen(s);i++)  &#123;    if(j==0||s[i]==t[j])    &#123;      j++;    &#125;    else    &#123;      j=next[j-1];    &#125;  &#125;  if(j==strlen(t))  &#123;    return i-j;  &#125;  return -1;&#125;\n\n\n\n演示代码我们将两个函数合并，并运行一下程序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include&lt;string.h&gt;void getNext(char *p, int *next)&#123;    int j = 0;    next[0] = 0; // 第一个字符没有前后缀    for (int i = 1; i &lt; strlen(p); i++)    &#123;        while (j &gt; 0 &amp;&amp; p[i] != p[j])        &#123;            j = next[j - 1];        &#125;        if (p[i] == p[j])        &#123;            j++;        &#125;        next[i] = j;    &#125;&#125;int kmp(char s[], char t[])&#123;    int j = 0;    int n = strlen(t);    int next[n];    getNext(t, next);    for (int i = 0; i &lt; strlen(s); i++)    &#123;        while (j &gt; 0 &amp;&amp; s[i] != t[j])        &#123;            j = next[j - 1];        &#125;        if(s[i]==t[j])        &#123;            j++;        &#125;        if (j == strlen(t))        &#123;            return i - j+1;        &#125;    &#125;    return -1;&#125;int main()&#123;    char s[10];    scanf(&quot;%s&quot;,s);    char t[10];    scanf(&quot;%s&quot;,t);    getchar();    printf(&quot;%d\\n&quot;, kmp(s, t) + 1);    return 0;&#125;\n\n\n\n结果\n\n\n正确输出结果，abac 在 ababac 中第一次出现未知是 3。\n总结KMP 算法对于初学者来说确实会有些迷惑，但是只要理解了核心思想，现在看来也还是蛮简单的对吧。希望这对你学习 KMP 算法有所帮助\n部分内容来自 代码随想录 \n","slug":"KMP匹配算法","date":"2023-10-29T10:09:30.000Z","categories_index":"笔记","tags_index":"算法,数据结构,C 语言","author_index":"Mesonsaber"}]