[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-10-30T08:17:15.339Z","categories_index":"","tags_index":"","author_index":"Mesonsaber"},{"id":"3a720846f06b194cf852fdd1addeae93","title":"KMP匹配算法","content":"KMP匹配算法思路将待查询字符串 searchString 使用一串 next 数组表表示，当与源字符串 sourceString 匹配时，sourceString 不需要移动，只需要将 searchString 移动n位，然后再继续匹配，直到结束。\nnext 数组next 数组的值就是代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果 next[j]&#x3D;k，代表 j 之前的字符串中有最大长度为 k 的相同前缀后缀。\n至于为什么要求next 数组，等我们知道了 next 数组是怎么求的之后，再告诉大家\n那么如何来求 next 数组呢？\n如图：\n\n长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）\n长度为前2个字符的子串aa，最长相同前后缀的长度为1。\n长度为前3个字符的子串aab，最长相同前后缀的长度为0。\n以此类推：长度为前4个字符的子串aaba，最长相同前后缀的长度为1。长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。\n那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：\n可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n理解原理后，我们来用代码实现一下\n首先我们定义 getNext 函数\n1void getNext(char *p,int *next)\n\n\n初始化\n对相应的变量初始化\n\n\n12int j=0;next[0]=0;\t\t\t//第一个字符没有前后缀\n\n\n前后缀不相同情况\n1234567for(int i=0;i&lt;strlen(p);i++)&#123;  while(j&gt;0||p[i]!=p[j])  &#123;    j=next[j-1];  &#125;&#125;\n\n前后缀相同情况\n1234if(p[i]==p[j])&#123;  j++;&#125;\n\n更新 next 数组\n1next[i]=j;\n\n合并代码\n1234567891011121314151617void getNext(char *p,int *next)&#123;  int j=0;\tnext[0]=0;\t\t\t//第一个字符没有前后缀  for(int i=0;i&lt;strlen(p);i++)  &#123;    while(j&gt;0||p[i]!=p[j])    &#123;      j=next[j-1];    &#125;    if(p[i]==p[j])    &#123;      j++;    &#125;    next[i]=j;  &#125;&#125;\n\n相信大家通过代码更加理解了如何求 next 数组了。\n匹配通过以上对 next 数组的理解之后，我们再来KMP 算法是如何匹配的，我们已知，next 数组所代表的就是最大前缀后缀值，也就是说，在失配字符前，有多少个可重复的前缀后缀，这也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j-1] 的位置，也就是在失配字符之前已经重复出现过的前缀的后一个字符）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] &#x3D; k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。\n图例表示\n\n可以看到，当失配时，会跳到当前字符p[j]前一个字符p[j-1]的 next[j-1]值所指的字符，然后接着匹配，直至全部匹配到。\n我们可以简单的用代码表示\n1234567891011121314151617181920int kmp(char *s,char *t)&#123;  int j=0;  for(int i=0;i&lt;strlen(s);i++)  &#123;    if(j==0||s[i]==t[j])    &#123;      j++;    &#125;    else    &#123;      j=next[j-1];    &#125;  &#125;  if(j==strlen(t))  &#123;    return i-j;  &#125;  return -1;&#125;\n\n\n\n演示代码我们将两个函数合并，并运行一下程序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include&lt;string.h&gt;void getNext(char *p, int *next)&#123;    int j = 0;    next[0] = 0; // 第一个字符没有前后缀    for (int i = 1; i &lt; strlen(p); i++)    &#123;        while (j &gt; 0 &amp;&amp; p[i] != p[j])        &#123;            j = next[j - 1];        &#125;        if (p[i] == p[j])        &#123;            j++;        &#125;        next[i] = j;    &#125;&#125;int kmp(char s[], char t[])&#123;    int j = 0;    int n = strlen(t);    int next[n];    getNext(t, next);    for (int i = 0; i &lt; strlen(s); i++)    &#123;        while (j &gt; 0 &amp;&amp; s[i] != t[j])        &#123;            j = next[j - 1];        &#125;        if(s[i]==t[j])        &#123;            j++;        &#125;        if (j == strlen(t))        &#123;            return i - j+1;        &#125;    &#125;    return -1;&#125;int main()&#123;    char s[10];    scanf(&quot;%s&quot;,s);    char t[10];    scanf(&quot;%s&quot;,t);    getchar();    printf(&quot;%d\\n&quot;, kmp(s, t) + 1);    return 0;&#125;\n\n\n\n结果\n\n\n正确输出结果，abac 在 ababac 中第一次出现未知是 3。\n总结KMP 算法对于初学者来说确实会有些迷惑，但是只要理解了核心思想，现在看来也还是蛮简单的对吧。希望这对你学习 KMP 算法有所帮助\n部分内容来自*代码随想录*\n","slug":"KMP匹配算法","date":"2023-10-30T02:50:04.357Z","categories_index":"","tags_index":"","author_index":"Mesonsaber"}]