[{"id":"70c0c770528c6f3eab2585436d750f40","title":"JavaScript事件对象","content":"事件对象什么是事件对象\n也是一个对象，对象中有事件触发时的相关信息\n例如：鼠标点击事件中，事件对象就存放了鼠标点在了哪个位置等信息\n\n使用场景是什么\n可以判断用户按下哪个键，比如按下回车可以发布留言\n可以判断鼠标点击了哪个元素，从而做出相应的操作\n\n获取事件对象\n语法\n\n在事件绑定的回调函数的第一个参数就是事件对象\n\n1234Element.addEventListener(&#x27;click&#x27;, function(e)&#123;  //e就是事件对象  //可以使用e.方法名/属性名来使用事件对象&#125;)\n\n\n\n\n举个🌰\n\n12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button type=&quot;button&quot;&gt;点击&lt;/button&gt;    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt;    &lt;script&gt;        const input = document.querySelector(&#x27;input&#x27;)        input.addEventListener(&#x27;keyup&#x27;,function(e)&#123;            //使用key属性获取用户按的是哪个键            if(e.key === &#x27;Enter&#x27;)       //判断用户按下的是不是回车键            &#123;                console.log(&#x27;回车键按下&#x27;);            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n效果\n\n\n\n\n\n部分常用属性\n\ntype\n\n获取当前事件类型\n\n\nclientX&#x2F;clientY\n\n获取光标相对于浏览器可见窗口左上角的位置\n1console.log(e.clientX);\n\n\n\n\n\noffsetX&#x2F;offsetY\n\n获取光标相对于当前 DOM 元素左上角的位置\n1console.log(e.offsetX);\n\n\n\n\n\nkey\n\n用户按下的键盘键的值\n\n1console.log(e.key)\n\n\n\n\n\n\n案例实现按下回车发送消息\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;评论回车发布&lt;/title&gt;  &lt;style&gt;    .wrapper &#123;      min-width: 400px;      max-width: 800px;      display: flex;      justify-content: flex-end;    &#125;    .avatar &#123;      width: 48px;      height: 48px;      border-radius: 50%;      overflow: hidden;      background: url(./images/avatar.jpg) no-repeat center / cover;      margin-right: 20px;    &#125;    .wrapper textarea &#123;      outline: none;      border-color: transparent;      resize: none;      background: #f5f5f5;      border-radius: 4px;      flex: 1;      padding: 10px;      transition: all 0.5s;      height: 30px;    &#125;    .wrapper textarea:focus &#123;      border-color: #e4e4e4;      background: #fff;      height: 50px;    &#125;    .wrapper button &#123;      background: #00aeec;      color: #fff;      border: none;      border-radius: 4px;      margin-left: 10px;      width: 70px;      cursor: pointer;    &#125;    .wrapper .total &#123;      margin-right: 80px;      color: #999;      margin-top: 5px;      opacity: 0;      transition: all 0.5s;    &#125;    .list &#123;      min-width: 400px;      max-width: 800px;      display: flex;    &#125;    .list .item &#123;      width: 100%;      display: flex;    &#125;    .list .item .info &#123;      flex: 1;      border-bottom: 1px dashed #e4e4e4;      padding-bottom: 10px;    &#125;    .list .item p &#123;      margin: 0;    &#125;    .list .item .name &#123;      color: #FB7299;      font-size: 14px;      font-weight: bold;    &#125;    .list .item .text &#123;      color: #333;      padding: 10px 0;    &#125;    .list .item .time &#123;      color: #999;      font-size: 12px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;i class=&quot;avatar&quot;&gt;&lt;/i&gt;    &lt;textarea id=&quot;tx&quot; placeholder=&quot;发一条友善的评论&quot; rows=&quot;2&quot; maxlength=&quot;200&quot;&gt;&lt;/textarea&gt;    &lt;button&gt;发布&lt;/button&gt;  &lt;/div&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;span class=&quot;total&quot;&gt;0/200字&lt;/span&gt;  &lt;/div&gt;  &lt;div class=&quot;list&quot;&gt;    &lt;div class=&quot;item&quot; style=&quot;display: none;&quot;&gt;      &lt;i class=&quot;avatar&quot;&gt;&lt;/i&gt;      &lt;div class=&quot;info&quot;&gt;        &lt;p class=&quot;name&quot;&gt;清风徐来&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;大家都辛苦啦，感谢各位大大的努力，能圆满完成真是太好了[笑哭][支持]&lt;/p&gt;        &lt;p class=&quot;time&quot;&gt;2022-10-10 20:29:21&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    const tx = document.querySelector(&#x27;#tx&#x27;)    const total = document.querySelector(&#x27;.total&#x27;)    const item = document.querySelector(&#x27;.item&#x27;)    const text = document.querySelector(&#x27;.text&#x27;)    //当文本域获得焦点，将 total 显示出来    tx.addEventListener(&#x27;focus&#x27;, function()&#123;      total.style.opacity = 1    &#125;)    //失去焦点，就将 total 隐藏    tx.addEventListener(&#x27;blur&#x27;, function()&#123;      total.style.opacity = 0    &#125;)    //检测用户输入    tx.addEventListener(&#x27;input&#x27;, function()&#123;      total.innerHTML=`$&#123;tx.value.length&#125;/200字`    &#125;)    //绑定键盘事件    tx.addEventListener(&#x27;keyup&#x27;,function(e)&#123;      if(e.key===&#x27;Enter&#x27;)      &#123;        if(tx.value.trim()!==&#x27;&#x27;)      //判断输入是否为空        &#123;          item.style.display = &#x27;block&#x27;          text.innerHTML=tx.value        &#125;        tx.value=&#x27;&#x27;   //  清空文本域        total.innerHTML=&#x27;0/200字&#x27;     //恢复字符数量      &#125;          &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n效果\n\n以后就尝试把笔记上传到自己的博客上，不逼一下自己，这些东西容易忘\n","slug":"JavaScript事件对象","date":"2023-10-30T12:00:06.000Z","categories_index":"笔记","tags_index":"JavaScript","author_index":"Mesonsaber"},{"id":"3a720846f06b194cf852fdd1addeae93","title":"KMP匹配算法","content":"KMP匹配算法思路将待查询字符串 searchString 使用一串 next 数组表表示，当与源字符串 sourceString 匹配时，sourceString 不需要移动，只需要将 searchString 移动n位，然后再继续匹配，直到结束。\nnext 数组next 数组的值就是代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果 next[j]&#x3D;k，代表 j 之前的字符串中有最大长度为 k 的相同前缀后缀。\n至于为什么要求next 数组，等我们知道了 next 数组是怎么求的之后，再告诉大家\n那么如何来求 next 数组呢？\n如图：\n\n长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）\n长度为前2个字符的子串aa，最长相同前后缀的长度为1。\n长度为前3个字符的子串aab，最长相同前后缀的长度为0。\n以此类推：长度为前4个字符的子串aaba，最长相同前后缀的长度为1。长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。\n那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：\n可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n理解原理后，我们来用代码实现一下\n首先我们定义 getNext 函数\n1void getNext(char *p,int *next)\n\n\n初始化\n对相应的变量初始化\n\n\n12int j=0;next[0]=0;\t\t\t//第一个字符没有前后缀\n\n\n前后缀不相同情况\n1234567for(int i=0;i&lt;strlen(p);i++)&#123;  while(j&gt;0||p[i]!=p[j])  &#123;    j=next[j-1];  &#125;&#125;\n\n前后缀相同情况\n1234if(p[i]==p[j])&#123;  j++;&#125;\n\n更新 next 数组\n1next[i]=j;\n\n合并代码\n1234567891011121314151617void getNext(char *p,int *next)&#123;  int j=0;\tnext[0]=0;\t\t\t//第一个字符没有前后缀  for(int i=0;i&lt;strlen(p);i++)  &#123;    while(j&gt;0||p[i]!=p[j])    &#123;      j=next[j-1];    &#125;    if(p[i]==p[j])    &#123;      j++;    &#125;    next[i]=j;  &#125;&#125;\n\n相信大家通过代码更加理解了如何求 next 数组了。\n匹配通过以上对 next 数组的理解之后，我们再来KMP 算法是如何匹配的，我们已知，next 数组所代表的就是最大前缀后缀值，也就是说，在失配字符前，有多少个可重复的前缀后缀，这也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j-1] 的位置，也就是在失配字符之前已经重复出现过的前缀的后一个字符）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] &#x3D; k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。\n图例表示\n\n可以看到，当失配时，会跳到当前字符p[j]前一个字符p[j-1]的 next[j-1]值所指的字符，然后接着匹配，直至全部匹配到。\n我们可以简单的用代码表示\n1234567891011121314151617181920int kmp(char *s,char *t)&#123;  int j=0;  for(int i=0;i&lt;strlen(s);i++)  &#123;    if(j==0||s[i]==t[j])    &#123;      j++;    &#125;    else    &#123;      j=next[j-1];    &#125;  &#125;  if(j==strlen(t))  &#123;    return i-j;  &#125;  return -1;&#125;\n\n\n\n演示代码我们将两个函数合并，并运行一下程序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include&lt;string.h&gt;void getNext(char *p, int *next)&#123;    int j = 0;    next[0] = 0; // 第一个字符没有前后缀    for (int i = 1; i &lt; strlen(p); i++)    &#123;        while (j &gt; 0 &amp;&amp; p[i] != p[j])        &#123;            j = next[j - 1];        &#125;        if (p[i] == p[j])        &#123;            j++;        &#125;        next[i] = j;    &#125;&#125;int kmp(char s[], char t[])&#123;    int j = 0;    int n = strlen(t);    int next[n];    getNext(t, next);    for (int i = 0; i &lt; strlen(s); i++)    &#123;        while (j &gt; 0 &amp;&amp; s[i] != t[j])        &#123;            j = next[j - 1];        &#125;        if(s[i]==t[j])        &#123;            j++;        &#125;        if (j == strlen(t))        &#123;            return i - j+1;        &#125;    &#125;    return -1;&#125;int main()&#123;    char s[10];    scanf(&quot;%s&quot;,s);    char t[10];    scanf(&quot;%s&quot;,t);    getchar();    printf(&quot;%d\\n&quot;, kmp(s, t) + 1);    return 0;&#125;\n\n\n\n结果\n\n\n正确输出结果，abac 在 ababac 中第一次出现未知是 3。\n总结KMP 算法对于初学者来说确实会有些迷惑，但是只要理解了核心思想，现在看来也还是蛮简单的对吧。希望这对你学习 KMP 算法有所帮助\n部分内容来自 代码随想录 \n","slug":"KMP匹配算法","date":"2023-10-29T10:09:30.000Z","categories_index":"笔记","tags_index":"算法,数据结构,C 语言","author_index":"Mesonsaber"}]