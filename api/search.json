[{"id":"931902b40e7b49ead6194ab4ea55b9d1","title":"SpringBoot自动装配原理","content":"引入SpringBoot进一步简化了web应用开发步骤，其中一个很重要的核心概念就是自动装配，什么是自动装配？自动装配都做了些什么？\n自动装配概述以往我们使用Servlet+Tomcat做web开发时，往往需要自己再xml配置文件中配置一大堆东西，而且往往项目越大，需要配置的东西就越多，这不仅非常繁琐，而且还拖慢了开发周期，自动装配的出现就是为了简化开发过程中的前期配置准备，让程序员更专注于业务的开发和实现。\n自动装配核心理解12345678@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\n\n@SpringBootApplication在SpringBoot的入口类中，存在这样一个注解，我们接下来就从它来剖析一下自动配置的原理。\n进入注解的源码中，我们发现其有两个重要的注解\n12@SpringBootConfiguration@EnableAutoConfiguration\n\n@SpringBootConfiguration进入源码发现它只是被定义为了一个Spring注解，所以我们对它的探究就到这。\n1234567891011@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@Indexedpublic @interface SpringBootConfiguration &#123;    @AliasFor(        annotation = Configuration.class    )    boolean proxyBeanMethods() default true;&#125;\n\n@EnableAutoConfiguration观察注解名可以知道这应该是一个启用自动配置的注解\n进入它的源码，我们发现它有两个重要的注解\n12@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)\n\n@AutoConfigurationPackage从注解名我们可以先了解到，它是自动配置包注解。\n进入源码发现，它有一个重要注解\n1@Import(&#123;AutoConfigurationPackages.Registrar.class&#125;)\n\n@Import({AutoConfigurationPackages.Registrar.class})查看源码可以发现，它其中的Registrar静态类是关键，通过AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]))方法注册了某些东西，我们继续深入。\n123456789101112static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;    Registrar() &#123;    &#125;    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;        AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]));    &#125;    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;        return Collections.singleton(new PackageImports(metadata));    &#125;&#125;\n\n我们找到了PackageImports的构造函数，发现它貌似是获得AutoConfigurationPackage注解下的包，然后将添加到了packageNames这个List数组中。最后再回到registerBeanDefinitions方法中将其注册为。\n1AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));\n\n1234567891011121314PackageImports(AnnotationMetadata metadata) &#123;    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));    List&lt;String&gt; packageNames = new ArrayList(Arrays.asList(attributes.getStringArray(&quot;basePackages&quot;)));    for(Class&lt;?&gt; basePackageClass : attributes.getClassArray(&quot;basePackageClasses&quot;)) &#123;        packageNames.add(basePackageClass.getPackage().getName());    &#125;    if (packageNames.isEmpty()) &#123;        packageNames.add(ClassUtils.getPackageName(metadata.getClassName()));    &#125;    this.packageNames = Collections.unmodifiableList(packageNames);&#125;\n\n@Import({AutoConfigurationImportSelector.class})它引入了AutoConfigurationImportSelector这个类，所以接下来我们要探究这个类是做什么的。\n看类名感觉应该是自动配置引用选择器，观察源码。\n找到selectImports(AnnotationMetadata annotationMetadata)方法的实现，我们观察方法实现，发现它通过this.getAutoConfigurationEntry(annotationMetadata)获得了一个自动配置实体，接下来我们来研究一下getAutoConfigurationEntry(annotationMetadata)这个方法。\n12345678public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;if (!this.isEnabled(annotationMetadata)) &#123;    return NO_IMPORTS;&#125; else &#123;    AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125;&#125;\n\n定位到方法实现，发现它使用了this.getAttributes方法来获得传入参数的属性，而this.getAttributes这个方法返回了EnableAutoConfiguration这个注解名，也就是说，只有使用了@EnableAutoConfiguration这个注解的类，才会启用自动配置。\n1234567891011121314151617181920212223242526272829protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;if (!this.isEnabled(annotationMetadata)) &#123;    return EMPTY_ENTRY;&#125; else &#123;    AnnotationAttributes attributes = this.getAttributes(annotationMetadata);    List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);    configurations = this.&lt;String&gt;removeDuplicates(configurations);    Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);    this.checkExcludedClasses(configurations, exclusions);    configurations.removeAll(exclusions);    configurations = this.getConfigurationClassFilter().filter(configurations);    this.fireAutoConfigurationImportEvents(configurations, exclusions);    return new AutoConfigurationEntry(configurations, exclusions);&#125;&#125;    protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) &#123;        String name = this.getAnnotationClass().getName();        AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, true));        Assert.notNull(attributes, () -&gt; &#123;            String var10000 = metadata.getClassName();            return &quot;No auto-configuration attributes found. Is &quot; + var10000 + &quot; annotated with &quot; + ClassUtils.getShortName(name) + &quot;?&quot;;        &#125;);        return attributes;    &#125;    protected Class&lt;?&gt; getAnnotationClass() &#123;        return EnableAutoConfiguration.class;    &#125;\n\n那么到底要自动配置哪些类呢，在哪里可以找到SpringBoot能自动配置的类？我们继续往下看，getCandidateConfigurations()，我们进入这个方法的实现。\n123456protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;    ImportCandidates importCandidates = ImportCandidates.load(this.autoConfigurationAnnotation, this.getBeanClassLoader());    List&lt;String&gt; configurations = importCandidates.getCandidates();    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring/&quot; + this.autoConfigurationAnnotation.getName() + &quot;.imports. If you are using a custom packaging, make sure that file is correct.&quot;);    return configurations;&#125;\n\n\n\n发现它的实现中使用了ImportCandidates.load这样一个方法，我们发现，它是从META-INF/spring/%s.imports这个文件下加载自动配置类的。\n:::info这里需要注意，如果你学过SpringBoot2，就会发现这里有所不同，在SpringBoot2中，是从/META_INF/spring.factories这个文件下加载自动装配类的，而在SpringBoot3中抛弃了这种方法，SpringBoot3使用ImportCandidates.load方法从META-INF/spring/%s.imports加载自动配置类，但是/META_INF/spring.factories这个文件依然存在，只是其中不再包含需要自动配置的类，这样改变有许多好处，在这先不介绍。\n:::\n1234567891011121314public static ImportCandidates load(Class&lt;?&gt; annotation, ClassLoader classLoader) &#123;        Assert.notNull(annotation, &quot;&#x27;annotation&#x27; must not be null&quot;);        ClassLoader classLoaderToUse = decideClassloader(classLoader);        String location = String.format(&quot;META-INF/spring/%s.imports&quot;, annotation.getName());        Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);        List&lt;String&gt; importCandidates = new ArrayList();        while(urls.hasMoreElements()) &#123;            URL url = (URL)urls.nextElement();            importCandidates.addAll(readCandidateConfigurations(url));        &#125;        return new ImportCandidates(importCandidates);&#125;\n\n我们可以打开这个文件看看\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfigurationorg.springframework.boot.autoconfigure.aop.AopAutoConfigurationorg.springframework.boot.autoconfigure.amqp.RabbitAutoConfigurationorg.springframework.boot.autoconfigure.batch.BatchAutoConfigurationorg.springframework.boot.autoconfigure.cache.CacheAutoConfigurationorg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfigurationorg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfigurationorg.springframework.boot.autoconfigure.context.LifecycleAutoConfigurationorg.springframework.boot.autoconfigure.context.MessageSourceAutoConfigurationorg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfigurationorg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfigurationorg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfigurationorg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfigurationorg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.redis.RedisAutoConfigurationorg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfigurationorg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfigurationorg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfigurationorg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfigurationorg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchClientAutoConfigurationorg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfigurationorg.springframework.boot.autoconfigure.elasticsearch.ReactiveElasticsearchClientAutoConfigurationorg.springframework.boot.autoconfigure.flyway.FlywayAutoConfigurationorg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfigurationorg.springframework.boot.autoconfigure.graphql.GraphQlAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlReactiveQueryByExampleAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlReactiveQuerydslAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlQueryByExampleAutoConfigurationorg.springframework.boot.autoconfigure.graphql.data.GraphQlQuerydslAutoConfigurationorg.springframework.boot.autoconfigure.graphql.reactive.GraphQlWebFluxAutoConfigurationorg.springframework.boot.autoconfigure.graphql.rsocket.GraphQlRSocketAutoConfigurationorg.springframework.boot.autoconfigure.graphql.rsocket.RSocketGraphQlClientAutoConfigurationorg.springframework.boot.autoconfigure.graphql.security.GraphQlWebFluxSecurityAutoConfigurationorg.springframework.boot.autoconfigure.graphql.security.GraphQlWebMvcSecurityAutoConfigurationorg.springframework.boot.autoconfigure.graphql.servlet.GraphQlWebMvcAutoConfigurationorg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfigurationorg.springframework.boot.autoconfigure.gson.GsonAutoConfigurationorg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfigurationorg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfigurationorg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfigurationorg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfigurationorg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfigurationorg.springframework.boot.autoconfigure.http.client.HttpClientAutoConfigurationorg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfigurationorg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfigurationorg.springframework.boot.autoconfigure.integration.IntegrationAutoConfigurationorg.springframework.boot.autoconfigure.jackson.JacksonAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.JdbcClientAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfigurationorg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfigurationorg.springframework.boot.autoconfigure.jersey.JerseyAutoConfigurationorg.springframework.boot.autoconfigure.jms.JmsAutoConfigurationorg.springframework.boot.autoconfigure.jmx.JmxAutoConfigurationorg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfigurationorg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfigurationorg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfigurationorg.springframework.boot.autoconfigure.jooq.JooqAutoConfigurationorg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfigurationorg.springframework.boot.autoconfigure.kafka.KafkaAutoConfigurationorg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfigurationorg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfigurationorg.springframework.boot.autoconfigure.ldap.LdapAutoConfigurationorg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfigurationorg.springframework.boot.autoconfigure.mail.MailSenderAutoConfigurationorg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfigurationorg.springframework.boot.autoconfigure.mongo.MongoAutoConfigurationorg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfigurationorg.springframework.boot.autoconfigure.mustache.MustacheAutoConfigurationorg.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfigurationorg.springframework.boot.autoconfigure.netty.NettyAutoConfigurationorg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfigurationorg.springframework.boot.autoconfigure.pulsar.PulsarAutoConfigurationorg.springframework.boot.autoconfigure.pulsar.PulsarReactiveAutoConfigurationorg.springframework.boot.autoconfigure.quartz.QuartzAutoConfigurationorg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfigurationorg.springframework.boot.autoconfigure.r2dbc.R2dbcProxyAutoConfigurationorg.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfigurationorg.springframework.boot.autoconfigure.reactor.ReactorAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfigurationorg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfigurationorg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfigurationorg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfigurationorg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfigurationorg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfigurationorg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfigurationorg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfigurationorg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfigurationorg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfigurationorg.springframework.boot.autoconfigure.session.SessionAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.server.servlet.OAuth2AuthorizationServerAutoConfigurationorg.springframework.boot.autoconfigure.security.oauth2.server.servlet.OAuth2AuthorizationServerJwtAutoConfigurationorg.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfigurationorg.springframework.boot.autoconfigure.ssl.SslAutoConfigurationorg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfigurationorg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfigurationorg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfigurationorg.springframework.boot.autoconfigure.transaction.TransactionAutoConfigurationorg.springframework.boot.autoconfigure.transaction.TransactionManagerCustomizationAutoConfigurationorg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfigurationorg.springframework.boot.autoconfigure.validation.ValidationAutoConfigurationorg.springframework.boot.autoconfigure.web.client.RestClientAutoConfigurationorg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfigurationorg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfigurationorg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfigurationorg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfigurationorg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfigurationorg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfigurationorg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n\n我们发现它们全都以xxxAutoConfiguration来表示。\n思维导图表示接下来我用思维导图的方式展示一下具体的实现原理\n\n自动配置流程理解SpringBoot自动配置帮我们将所有存在于META-INF/spring/%s.imports的类都配置了，但是并不是我们全都会用上，那么SpringBoot是如何判断哪些是我们需要的，哪些不是呢？\n@Conditional 条件匹配（1）@ConditionalOnClass确保某个类存在才进行自动装配：\n1234@ConditionalOnClass(DataSource.class)@Configurationpublic class DataSourceAutoConfiguration &#123;&#125;\n\n只有当 DataSource.class 存在时，DataSourceAutoConfiguration 才会生效。\n（2）@ConditionalOnMissingBean确保没有自定义 Bean 时，才进行自动装配：\n12345@Bean@ConditionalOnMissingBeanpublic DataSource dataSource() &#123;    return new HikariDataSource();&#125;\n\n如果自己定义了 DataSource，这个 Bean不会被创建。\n（3）@ConditionalOnProperty检查配置文件是否开启某个功能：\n1234@ConditionalOnProperty(name = &quot;spring.datasource.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)@Configurationpublic class DataSourceAutoConfiguration &#123;&#125;\n\n如果 spring.datasource.enabled=true，则启用自动配置。\n通过一系列判断，SpringBoot能够自动选择到底要注册哪些类。\n如何知道哪些类能配置我们知道SpringBoot会从META-INF/spring/%s.imports文件中自动配置类，而这个文件中类的名称都是xxxxAutoConfiguration，比如常见的SessionAutoConfiguration\n1234567@AutoConfiguration(    after = &#123;DataSourceAutoConfiguration.class, HazelcastAutoConfiguration.class, JdbcTemplateAutoConfiguration.class, MongoDataAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class, RedisAutoConfiguration.class, RedisReactiveAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class&#125;,    before = &#123;HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class&#125;)@ConditionalOnClass(&#123;Session.class&#125;)@ConditionalOnWebApplication@EnableConfigurationProperties(&#123;ServerProperties.class, SessionProperties.class, WebFluxProperties.class&#125;)\n\n在@EnableConfigurationProperties()注解中的类就是我们能在配置文件中配置的类，比如ServerProperties.class，发现@ConfigurationProperties配置的就是我们在配置文件中写的server.xxxx，这个类的属性就是我们能配置的值，比如port。\n12345678910111213141516171819202122232425@ConfigurationProperties(&quot;server&quot;)public class ServerProperties &#123;    private Integer port;    private InetAddress address;    @NestedConfigurationProperty    private final ErrorProperties error = new ErrorProperties();    private ForwardHeadersStrategy forwardHeadersStrategy;    private String serverHeader;    private DataSize maxHttpRequestHeaderSize = DataSize.ofKilobytes(8L);    private Shutdown shutdown;    @NestedConfigurationProperty    private Ssl ssl;    @NestedConfigurationProperty    private final Compression compression;    private final MimeMappings mimeMappings;    @NestedConfigurationProperty    private final Http2 http2;    private final Servlet servlet;    private final Reactive reactive;    private final Tomcat tomcat;    private final Jetty jetty;    private final Netty netty;    private final Undertow undertow;    .....&#125;\n\n所以我们能发现，哪些类我们能配置其实可以从META-INF/spring/%s.imports文件下各种AutoConfiguration类中找到，我们就不需要去死记硬背了。\n总结以上，我简单介绍了SpringBoot自动装配原理，以及自动配置流程，希望对你有所帮助。\n","slug":"SpringBoot自动装配原理","date":"2025-04-12T08:59:02.000Z","categories_index":"笔记","tags_index":"笔记,SpringBoot","author_index":"Mesonsaber"},{"id":"fbbfb14bbd36bacdc14feb17917b934a","title":"MVC架构","content":"MVC架构我们在开发Javaweb应用时，往往需要使用Servlet来实现业务逻辑，一般情况下，我们会将一个业务的实现逻辑写在一个Servlet类中，它可能会包含数据获取，业务实现，数据输出，假设我们需要编写一个银行转账业务，我们需要在Servlet中编写从数据库获取数据、转账业务实现等等操作，这可能会导致我们在一个Servlet中写了许多代码，而且代码耦合度很高，代码复用性也很差，我们能不能将这些代码拆分成一个个类似Vue中的组件，一个业务逻辑就是一个组件，页面展示是一个组件，数据的控制是一个组件，由此，我们引入了MVC架构模式。\n概述MVC（Model-View-Cotroller）是一种软件架构模式，旨在通过职责分离提升代码的可维护性和扩展性\nMVC三大件Model（模型）\n职责：管理应用程序的数据和业务逻辑。\n处理数据\n封装业务\n\n\n\nView（视图）\n职责：呈现数据并与用户交互\n展示Model的数据\n接收用户操作，不处理逻辑，将操作传递给Controller\n\n\n\nController（控制器）\n职责：协调Model和View\n接收用户输入（HTTP请求），调用对应Model处理\n根据Model结果选择View渲染\n\n\n\nMVC工作流程以用户登录为例：\n\n用户发起登录请求：在浏览器填写表单，点击登录（View层触发）\nController接收请求：解析用户输入。\nModel处理数据：验证用户信息，查询数据库。\n更新View：根据Model返回结果，Controller调用相应View\n\n总结MVC通过分层设计解决了代码混乱的问题，适用于中大型项目或需要长期维护的系统。\n","slug":"MVC架构","date":"2025-04-03T13:47:22.000Z","categories_index":"笔记","tags_index":"JavaWeb,笔记","author_index":"Mesonsaber"},{"id":"c67ce29f34ee2d9d72274617ca0bb9bd","title":"JSP 九大内置对象","content":"JSP九大内置对象哪九个内置对象？\njakarta.servlet.http.HttpServletRequest request\njakarta.servlet.http.HttpServletResponse response\njakarta.servlet.jsp.PageContext pageContext\njakarta.servlet.http.HttpSession session\njava.lang.Throwable exception\njakarta.servlet.ServletContext application\njakarta.servlet.ServletConfig config\njakarta.servlet.jsp.JspWriter out\njava.lang.Object page\n\n都是干嘛的​\t其中，request,pageContext,session,application这四个对象属于作用域对象。\npageContext属于页面作用域，request属于请求作用域，session属于会话作用域，application属于应用作用域。\n四个域的作用范围：pageContext&lt;request&lt;session&lt;application\n四个域都有：setAttribute，getAttribute,removeAttribute方法。\n使用原则：尽量使用范围小的域。\n​\texception属于Throwable对象，负责输出异常信息。\n​\tpage就是this，指当前页面jsp对象。\n​\tout负责文本输出。\n​\tresponse负责响应。\n​\tconfig是Servlet的配置信息。\n","slug":"JSP-九大内置对象","date":"2025-04-02T11:01:56.000Z","categories_index":"笔记","tags_index":"JavaWeb,笔记","author_index":"Mesonsaber"},{"id":"9a1999a60d81f143647e177af12b114b","title":"Cookie理论基础","content":"Cookie的理论基础什么是CookieCookie是由服务器生成的一段纯文本数据，通过HTTP响应头(Set-Cookie)发送给浏览器 (JavaEE中通过new Cookie(name,value)来创建Cookie，使用request.addCookie将Cookie发送到浏览器中) ，并由浏览器存储在本地。随后，每次向同一服务器发起请求时，浏览器都会在HTTP请求头中带上相应的Cookie，从而帮助服务器识别用户和维护会话状态。\n与Session的区别Cookie和Session机制都是为了保存会话状态，Cookie将会话状态保存在浏览器本地，Session将会话状态保存在服务器端。\nJavaEE中使用Cookie在JavaEE中提供有Cookie类，可以对Cookie进行操作。\n1234567891011//创建cookie对象Cookie cookie = new Cookie(&quot;cookie&quot;, &quot;1234&quot;);//设置cookie的存在时间//value&gt;0则保存在硬盘中//value=0则表示删除同名cookie//value&lt;0则cookie不会被存储到硬盘文件中，会放在浏览器运行内存中cookie.setMaxAge(3600);//Change the cookie&#x27;s Path to project&#x27;s context pathcookie.setPath(req.getContextPath());//把cookie传到浏览器resp.addCookie(cookie);\n\n新建的Cookie默认Path是创建Cookie路径的上一级，比如在servlet&#x2F;cookie这个路径创建Cookie，那么默认路径就是&#x2F;servlet，在servlet之下的路径都可以正常获Cookie。\n想要从浏览器中获取Cookie，使用request.getCookies()方法，它返回浏览器中指定路径下的所有Cookie数组。\n12345678Cookie[] cookies = req.getCookies();if (cookies != null) &#123;    for (Cookie cookie : cookies) &#123;         String name = cookie.getName();         String value = cookie.getValue();         System.out.println(name+&quot;=&quot;+value);    &#125;&#125;\n\n\n\n","slug":"Cookie理论基础","date":"2025-03-31T11:43:06.000Z","categories_index":"笔记","tags_index":"笔记","author_index":"Mesonsaber"},{"id":"9fe8d71f2f383c0ca8dbe4af2c600738","title":"不能把 jsp 文件放在 WEB-INF 文件夹中","content":"切记！！JavaWeb 项目中，如果你有 jsp 或者 html 页面展示文件，不能将它放在 WEB-INF 目录中，这样会导致访问路径时出现请求资源不可用的错误！！\n真的要牢记，我就因为这个小小错误，硬控我一个多小时的时间，我哭死。。。\n","slug":"不能把-jsp-文件放在-WEB-INF-文件夹中","date":"2025-03-14T09:21:47.000Z","categories_index":"","tags_index":"JavaWeb,笔记","author_index":"Mesonsaber"},{"id":"fc209dd052d70f296f5bae56a493f474","title":"手写 SpringIOC 框架","content":"为啥要手写 Spring IOC 框架通过自己写一遍框架，可以更好理解 SpringIOC 的底层原理。\n准备阶段创建myspring模块\n引入相关依赖因为需要解析 XML 文件，所以需要用到 dom4j 组件解析 XML 文件\n123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.myspringframework&lt;/groupId&gt;    &lt;artifactId&gt;myspring&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;!--dom4j是一个能够解析 XML 的 java 组件--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;            &lt;version&gt;2.1.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jaxen&lt;/groupId&gt;            &lt;artifactId&gt;jaxen&lt;/artifactId&gt;            &lt;version&gt;1.2.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;&lt;/project&gt;\n\n准备好要管理的 BeanVip类1234567891011121314151617181920212223package com.haishili.myspring.bean;public class Vip &#123;    private String name;    private int age;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Vip&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nOrderDao类12345678package com.haishili.myspring.bean;public class OrderDao &#123;    public void insert() &#123;        System.out.println(&quot;正在保存订单信息&quot;);    &#125;&#125;\n\nOrderService类1234567891011121314package com.haishili.myspring.bean;public class OrderService &#123;    private OrderDao orderDao;    public void setOrderDao(OrderDao orderDao) &#123;        this.orderDao = orderDao;    &#125;    public void save() &#123;        orderDao.insert();    &#125;&#125;\n\n写好配置文件123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans&gt;    &lt;bean id=&quot;vip&quot; class=&quot;com.haishili.myspring.bean.Vip&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;jack&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;19&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;orderDao&quot; class=&quot;com.haishili.myspring.bean.OrderDao&quot;/&gt;    &lt;bean id=&quot;orderService&quot; class=&quot;com.haishili.myspring.bean.OrderService&quot;&gt;        &lt;property name=&quot;orderDao&quot; ref=&quot;orderDao&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n编写阶段编写 ApplicationContext接口ApplicationContext接口提供了一个 getBean 方法用于获取相应 bean 对象，这个方法需要提供具体 Bean 名称。\n12345678package org.myspringframework.core;//MySpring 框架应用上下文接口public interface ApplicationContext &#123;    //根据 Bean 的名称获取对应的 bean 对象    Object getBean(String name);&#125;\n\n编写 ClassPathXmlApplicationContext 类ClassPathXmlApplicationContext类实现 ApplicationContext接口，并重写 getBean 方法。\nClassPathXmlApplicationContext有一个构造方法，在使用 Spring 的时候，我们会在ClassPathXmlApplicationContext构造方法中传入spring.xml这个配置文件的路径，以此让它解析 xml 文件。因此我们在写ClassPathXmlApplicationContext类时也需要接收spring.xml的路径。\n我们知道，在Singleton Bean 中，为了解决循环依赖的问题，Spring使用三重缓存机制，简单的说就是通过提前曝光 Bean 对象，再为属性赋值，这样来解决循环依赖的问题，因为我们也需要让 Bean 提前曝光。\n我们使用 Map 集合存放 Bean 对象，键值对分别是 id和Bean 对象。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package org.myspringframework.core;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;import java.io.InputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;public class ClassPathXmlApplicationContext implements ApplicationContext &#123;    private Map&lt;String, Object&gt; singletons = new HashMap&lt;&gt;();    //接收 xml 配置文件路径并解析配置文件，初始化所有 Bean 对象    public ClassPathXmlApplicationContext(String configLocation) &#123;        try&#123;            //解析 myspring.xml文件，然后实例化 Bean，将 Bean 存放到singletons集合中            //这是 dom4j 解析 XML 文件的核心对象            SAXReader reader = new SAXReader();            //获取一个输入流，指向配置文件            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(configLocation);            //读文件            Document doc = reader.read(is);            //获取所有 bean 标签            List&lt;Node&gt; nodes = doc.selectNodes(&quot;//bean&quot;);            //遍历 bean 标签            for (Node node : nodes) &#123;                //向下转型，使用 Element 接口里的更多方法                Element beanElement = (Element) node;                //获取 id                String id = beanElement.attributeValue(&quot;id&quot;);                //获取 className                String className = beanElement.attributeValue(&quot;class&quot;);                //通过反射机制创建对象，将其放入 Map 集合提前曝光                Class&lt;?&gt; clazz = Class.forName(className);                Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor();                Object instance = declaredConstructor.newInstance();                singletons.put(id, instance);            &#125;            //为属性赋值            nodes.forEach(node -&gt; &#123;                try&#123;                    Element element = (Element) node;                    //获取 id                    String id = element.attributeValue(&quot;id&quot;);                    //获取 className                    String className = element.attributeValue(&quot;class&quot;);                    //获取 class                    Class&lt;?&gt; clazz = Class.forName(className);                    //获取该 bean 标签下所有的 property 标签                    List&lt;Element&gt; propertys = element.elements(&quot;property&quot;);                    //遍历所有的属性标签                    propertys.forEach(property -&gt; &#123;                        try &#123;                            //获取属性名                            String propertyName = property.attributeValue(&quot;name&quot;);                            //获取属性类型                            Field field = clazz.getDeclaredField(propertyName);                            //获取方法名                            String setMethodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);                            //获取方法                            Method method = clazz.getDeclaredMethod(setMethodName, field.getType());                            //获取 value                            String value = property.attributeValue(&quot;value&quot;);                            //获取 ref                            String ref = property.attributeValue(&quot;ref&quot;);                            Object actualValue = null;                            if (ref != null) &#123;                                //表示非简单类型值                                method.invoke(singletons.get(id), singletons.get(ref));                            &#125;                            if(value != null) &#123;                                //表示简单类型值                                //获取属性类型名                                String propertyTypeSimpleName = field.getType().getSimpleName();                                switch (propertyTypeSimpleName) &#123;                                    case &quot;boolean&quot;:                                        actualValue = Boolean.parseBoolean(value);                                        break;                                    case &quot;byte&quot;:                                        actualValue = Byte.parseByte(value);                                        break;                                    case &quot;short&quot;:                                        actualValue = Short.parseShort(value);                                        break;                                    case &quot;int&quot;:                                        actualValue = Integer.parseInt(value);                                        break;                                    case &quot;long&quot;:                                        actualValue = Long.parseLong(value);                                        break;                                    case &quot;float&quot;:                                        actualValue = Float.parseFloat(value);                                        break;                                    case &quot;double&quot;:                                        actualValue = Double.parseDouble(value);                                        break;                                    case &quot;char&quot;:                                        actualValue = value.charAt(0);                                        break;                                    case &quot;String&quot;:                                        actualValue = value;                                &#125;                                //调用方法                                method.invoke(singletons.get(id), actualValue);                            &#125;                        &#125; catch (Exception e ) &#123;                            e.printStackTrace();                        &#125;                    &#125;);                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    @Override    public Object getBean(String beanName) &#123;        return singletons.get(beanName);    &#125;&#125;\n\n\n\n打包发布点击 Lifecycle中的 package 打包为 jar 包\n\n测试12345678910111213141516171819package com.haishili.myspring.test;import com.haishili.myspring.bean.OrderService;import org.junit.Test;import org.myspringframework.core.ApplicationContext;import org.myspringframework.core.ClassPathXmlApplicationContext;public class MySpringTest &#123;    @Test    public void test() &#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;myspring.xml&quot;);        Object vip = applicationContext.getBean(&quot;vip&quot;);        System.out.println(vip);        OrderService orderService = (OrderService) applicationContext.getBean(&quot;orderService&quot;);        orderService.save();    &#125;&#125;\n\n结果\n","slug":"手写-SpringIOC-框架","date":"2024-11-05T14:28:40.000Z","categories_index":"笔记","tags_index":"Spring,Java","author_index":"Mesonsaber"},{"id":"2a1c9c4cc2eeb3e5662886a5a5254cb8","title":"Vue 生命周期","content":"Vue生命周期生命周期概念​\t官方解释\n​\t每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n​\t简单理解\n​\t简单来说就是Vue实例被创建时会经过很多步骤，比如beforeCreate(创建前)，created(完成创建)，beforeMount(挂载前)，mounted(完成挂载)…….\n在这些特殊时期，Vue提供了一些名为生命周期钩子的函数，也就是这些函数会在这些时期执行。你可以在这些函数中添加自己的代码。\n示例代码1234567891011121314151617181920212223&lt;html&gt;  &lt;body&gt;  \t&lt;div id=&quot;root&quot;&gt;        &lt;h1 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎使用VUE&lt;/h1&gt;    &lt;/div&gt;  &lt;/body&gt;    &lt;script&gt;  \tnew Vue(&#123;            el:&#x27;#root&#x27;,            data:&#123;                opacity:1            &#125;,      //当网页元素全部挂在完成时执行mount()中的代码      \t\t\tmounted():&#123;      \t\t\t\t\tsetInterval(()=&gt;&#123;      \t\t\t\t\t\tthis.opacity -=0.01      \t\t\t\t\t\tif(this.opacity &lt;= 0) this.opacity = 1    \t\t\t\t\t\t&#125;,16)    \t\t\t\t&#125;,        &#125;)  &lt;/script&gt;&lt;/html&gt;\n\n\n\n深入生命周期\n\n名词解释挂载阶段​\tInit Events &amp; Lifecycle：初始化：生命周期、事件，但数据处理还没开始。\n​\tbeforeCreate：这时无法通过vm访问到data中的数据、methods中的方法。\n​\tInit injections &amp; reactivity：初始化：数据监测、数据代理。\n​\tcreated：这时可以通过vm访问到data中的数据、methods中配置的方法。\n​\t：此阶段Vue开始解析模板，生成虚拟DOM（内存中），页面还不能显示解析好的内容。\n​\tbeforeMount：这时页面呈现的是未经Vue编译的DOM结构，所有对DOM的操作最终都不奏效。\n​\tCreate vm.$el and replace “el” with it：将内存中的虚拟DOM转为真实DOM插入页面。\n​\tmounted：页面中呈现的是经过Vue编译的DOM，对DOM操作有效（尽可能避免）。至此初始化过程结束，一般在此进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作。\n更新阶段​\tbeforeUpdate：数据发生了更新，此时数据是新的，但是页面是旧的，即：页面尚未和数据保持同步。\t\n​\tVirtual DOM re-render and patch：根据新数据，生成新的虚拟 DOM，随后与旧的虚拟 DOM 进行比较，最终完成页面更新，即：完成了 Model-&gt;View 的更新。\n​\tupdated：此时数据是新的，页面也是新的，即：页面和数据保持同步。\n销毁流程​\tbeforeDestroy：vm中所有的：data、methods、指令等等，都处于可用状态，马上要执行销毁过程，一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。\n​\tTeardow watchers,child components and event listeners：拆除监视者，孩子组件和事件监听者。\n​\tdestroyed：销毁完成。\n重要的钩子\nmounted()\n常在此钩子中进行发送 ajax 请求，启动定时器，绑定自定义事件，订阅消息等操作。\n\nbeforeDestroy()\n\n\n​\t常在此钩子中进行清除定时器，解绑自定义事件，取消订阅消息等操作。\n","slug":"Vue生命周期","date":"2024-04-20T01:09:00.000Z","categories_index":"笔记","tags_index":"JavaScript,Vue","author_index":"Mesonsaber"},{"id":"67e57f0cabb58a64dbb4d43ca7066cb5","title":"Vue 组件化","content":"Vue组件化为什么会有组件\n在传统方法编写一个前端应用时，往往会出现许多为了实现不同功能的文件比如某个区域的 CSS 文件，某个交互效果的 JS 文件，这样复杂的文件导致在使用传统方法编写应用时各个文件的依赖关系混乱，不好维护，而且代码复用率不高。\n\n引入了组件之后，我们将每个部分所用到的文件全部封装到对应的组件，这样即便于管理，也能够更好的复用。\n于是我们把组件定义为实现应用中局部功能代码和资源的集合，\n如何创建组件非单文件组件\n定义组件（创建组件）\n使用 Vue.extend创建，其中 options 和和 new Vue 时传入的 option几乎一样，但也有点区别：\n\nel 不要写，最终所有组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器。\ndata 必须写成函数，避免组件被复用时，数据存在引用关系。\n\n12345678910111213const simple = Vue.extend(&#123;  template:  `  &lt;div&gt;  \t&#123;&#123;a&#125;&#125;  \t&#123;&#123;name&#125;&#125;  &lt;/div&gt;  `,\tdata()&#123;    a:1,    name:&#x27;jack&#x27;  &#125;&#125;)\n\n\n\n注册组件\n\n局部注册：new Vue 的时候传入 components 选项。\n全局注册：Vue.component(‘组件名’,组件)。\n\n\n使用组件（写组件标签）\n&lt;组件名&gt;&lt;&#x2F;组件名&gt;\n\n\n几个注意点：\n\n关于组件名：\n\n​\t一个单词组成：\n​\t\t第一种写法（首字母小写）：school。\n​\t\t第二种写法（首字母大写）：School。\n​\t多个单词组成：\n​\t\t第一种写法（kebab-case 命名）：my-school。\n​\t\t第二种写法（CamelCase 命名）：MySchool（需要使用 Vue 脚手架支持）。\n​\t其他：\n​\t\t(1).组件名不能与 HTML 中已经存在的标签名重复.\n​\t\t(2).可以使用 name 配置项指定组件在开发者工具中的名字。\n\n关于组件标签：\n\n​\t第一种写法：&lt;school&gt;&lt;/school&gt;\n​\t第二种写法：&lt;school/&gt;\n​\t不使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。\n\n一个简写方式：\n\n​\tconst school = Vue.extend(option)可简写成：const school = option。\n单文件组件单文件组件是一个.vue后缀的文件，在其中可以写上 html 结构，js 脚本以及 css 样式。\n1234567891011&lt;template&gt;    &lt;!-- 组件结构 --&gt;&lt;/template&gt;&lt;script&gt;    //组件交互&lt;/script&gt;&lt;style&gt;    /*样式相关*/&lt;/style&gt;\n\n每一个部分的效果都需要单独创建一个 vue 文件，最后使用App.vue将各个 vue 文件汇总起来，使用import语句引入每个 vue 文件\n组件嵌套在一个组件中嵌套另一个组件，它们形成父子关系。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//必须先定义组件        const char = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;角色名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;角色住址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    name: &#x27;谷風　天音&#x27;,                    address: &#x27;東京都&#x27;                &#125;            &#125;        &#125;)        const game = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;游戏名称：&#123;&#123;gameName&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;开发公司：&#123;&#123;compane&#125;&#125;&lt;/h2&gt;                //在父组件的模板中写入子组件的标签                &lt;char&gt;&lt;/char&gt;                &lt;button @click=&quot;showName&quot;&gt;点我&lt;/button&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    gameName: &#x27;天使⭐️騒々 RE-BOOT！&#x27;,                    compane: &#x27;yuzusoft&#x27;                &#125;            &#125;,            methods: &#123;                showName() &#123;                    alert(&quot;死宅真恶心&quot;)                &#125;            &#125;,  \t\t\t\t\t//在组件中注册另一个组件            components:&#123;                char:char            &#125;        &#125;)        new Vue(&#123;            el: &quot;#app&quot;,            data: &#123;                title: &#x27;柚子社&#x27;            &#125;,            components: &#123;              //只需在 vm 中注册一个父组件即可。                game            &#125;,            methods: &#123;            &#125;        &#125;)\n\n\n\n通常可以创建一个 app 组件用来管理所有父组件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const char = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;角色名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;角色住址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    name: &#x27;谷風　天音&#x27;,                    address: &#x27;東京都&#x27;                &#125;            &#125;        &#125;)        const game = Vue.extend(&#123;            template: `            &lt;div&gt;                &lt;h2&gt;游戏名称：&#123;&#123;gameName&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;开发公司：&#123;&#123;compane&#125;&#125;&lt;/h2&gt;                &lt;char&gt;&lt;/char&gt;                &lt;button @click=&quot;showName&quot;&gt;点我&lt;/button&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    gameName: &#x27;天使⭐️騒々 RE-BOOT！&#x27;,                    compane: &#x27;yuzusoft&#x27;                &#125;            &#125;,            methods: &#123;                showName() &#123;                    alert(&quot;死宅真恶心&quot;)                &#125;            &#125;,            components:&#123;                char:char            &#125;        &#125;)       const gamer = Vue.extend(&#123;            template:            `            &lt;div&gt;                &lt;h2&gt;玩家名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data()&#123;                return &#123;                    name:&#x27;张三&#x27;                &#125;            &#125;        &#125;)        const app = Vue.extend(&#123;            template:            `            &lt;div&gt;                &lt;gamer&gt;&lt;/gamer&gt;                &lt;game&gt;&lt;/game&gt;            &lt;/div&gt;            `,            components:&#123;                gamer,                game            &#125;        &#125;)              new Vue(&#123;            template:`&lt;app&gt;&lt;/app&gt;`,            el: &quot;#root&quot;,            data: &#123;                title: &#x27;柚子社&#x27;            &#125;,            components: &#123;                app            &#125;,            methods: &#123;            &#125;        &#125;)\n\n\n\nVueComponent其实 Vue 组件就是一个 VUEComponent构造函数，在使用 Vue.extend时生成的。具体 VueComponent 做了什么我们还不去深究。\n每创建一个组件并使用时，都会会有一个全新的 VueComponent。\n在组件配置中，data 函数，methods中的函数，watch 中的函数，computed 中的函数，它们的 this 均是 VueComponent 实例对象。并不是 Vue 实例对象。\n使用Vue脚手架进行单组件开发安装脚手架使用 VueCLI(脚手架)，进行单组件开发是最合适不过的方式，所以接下来我们使用脚手架进行单组件开发。\n安装方法非常简短，在命令行使用npm install -g @vue/cli 或者yarn global add @vue/cli进行安装。\n使用脚手架安装完成后，根据脚手架官网给出的命令创建一个脚手架项目，vue create 项目名称 Vue会给你创建一个已经编写好的 helloworld 项目。\n我们在此基础上进行开发。使用我们也需要对 Vue 给的这个初始项目进行一些了解。\n首先是我们来看一下项目文件夹的结构\n\n从上到下依次是 node_modules(node 组件)，public(公开文件，展示在页面上的比如 html 入口文件)，src(单组件相关文件)，.gitignore（git忽略文件）,babel.config.js（babel配置文件），jsconfig.js（js 配置文件），下面两个都是包管理相关文件，然后是 readme 文件和 vue 配置文件，vue 配置文件可以修改脚手架相关的配置。\n首先我们来看 src 文件夹中的 main.js文件，这时 js 入口文件，一下是其中的代码，可以看到我们会在里面引入 App.vue。这里面比较重要的是render:h=&gt;h(App)这一行，具体这行代码是干什么的可以看注释。\n123456789101112131415161718import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;    //render 可以将模板渲染出来    //因为我们引入的是一个残缺版的 Vue，它无法将模板解析并渲染    //我们使用 render 函数就能吧模板解析出来    // renfer(createElement)&#123;    //     return createElement(&#x27;h1&#x27;,&#x27;hello&#x27;)    // &#125;    //render的完整语法就像上面这样    //使用箭头函数就能简化成下面的格式。    //所以下面这行代码就是讲 App 中的模板渲染出来  render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;)\n\n","slug":"Vue组件化(上)","date":"2024-04-20T01:09:00.000Z","categories_index":"笔记","tags_index":"JavaScript,Vue","author_index":"Mesonsaber"},{"id":"eb51f645a3e7cac33920cb6896f19b9e","title":"从零开始搭建个人博客","content":"搭建个人博客网站步骤为什么要搭建个人博客个人博客可以展示个人的专业知识、技能和经验，让其他人更好的了解你的能力和成就，对于一个程序员来说，个人博客可以是你展示自己学习的东西，可以让自己在简历上有点东西可以写（让 HR 对你刮目相看🤪），而且一个好的博客还能有点装B熟属性😂（是吧是吧）。\n那么怎么来从零开始搭建一个属于自己的博客呢🤔？现在就跟着我一起学习吧🎉！\n开始吧我在Mac上配置环境，如果你是用的是Windows系统，其实也没有什么问题，我会在有区别的地方特别标注😀。\n我分为这几个步骤：\n\n配置环境\n部署到Github\n愉快使用吧\n\n配置环境\n安装 node.js打开你的浏览器搜索node，或者直接点击这里跳转到node.js官网。然后就不用我说了吧，直接凭感觉来点击那个最应该是下载node.js的图标\n\n下载完后打开安装包一直下一步就行.安装完成之后，可以使用命令行来检验是否成功安装\n\n现实版本信息则表示安装成功🎉！\n\n使用npm&#x2F;cnpm 安装 hexo 镜像接下来就是使用cnpm命令来安装hexo镜像了（因为国内使用npm下载很慢，使用使用国内的cnpm源下载会比较快），\n\n所以首先我们安装cnpm\n\n1npm install -g npm --registry=https://registry.npm.taobao.org\n\nwindows系统可以使用（理论应该两个都行）\n1npm i -g cnpm --registry.npm.taobao.org  \n\n进行安装，完成后使用 cnpm -v来查看是否安装成功，显示出版本信息则表示安装成功🎉\n\n然后我们使用cnpm来安装hexo\n1cnpm install -g hexo-cli\n\nwindows系统也是这个命令\n\n\n\n\n\n\n同样也可以使用hexo -v来查看版本信息确定是否安装成功。\n\n初始化博客环境\n新建一个文件夹，用来存放你的博客文件，创建好之后，mac 系统只需要在终端中进到你刚创建的文件夹，然后使用sudo hexo init命令来初始化 hexo 博客，windows 系统需要打开 cmd，然后进入创建好的文件夹，使用 hexo init 来初始化博客，初始化之后，你的文件夹里会出现几个文件及文件夹，这些就是 hexo 生成的，之后如果你的博客出现了什么问题，只需要删除这个文件夹重新开始。\n\n\n\n​\t成功之后使用hexo s在本地预览网页，看看是否成功，\n\n​\t几个常用的 hexo 命令\n​\thexo g生成 hexo 网页，hexo s本地预览网页，hexo d部署到远端，hexo n &quot;文件名&quot;新建博客文件，默认时 markdown 文件\n部署到 Github\n注册 Github，很简单，这里就不细讲了\n\n创建存放博客文档的库\n\n\n库名称必须是你 github 的名字加.github.io\n\n点击 Create repository\n\n\n\n安装 git\n\ngit 是用来把本地 hexo 文件推送到你创建的 github 仓库的\n\n修改 config 文件\n\n修改_config.yml文件\n\n\n这个文件就在你博客文件夹里，repo 地址是你的库地址。\n\n\n\n将博客推送到 github 上\n\n生成 SShKey\n进入到你的博客文件夹，mac 系统在终端使用\n12git config --global user.name &quot;你的 github 名字&quot;git config --global user.eamil &quot;你注册 github 时使用的邮箱地址&quot;\n\n然后再使用这个命令来生成密钥，过程中你需要按三次空格，不需要设置密码。\n1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;\n\n然后使用cat ~/.ssh/id_rsa.pub来查看密钥信息，将显示的内容复制，然后打开 Github-Setting-Keys 页面，新建 SSH key，title 随便写都行，将复制的内容粘贴到Key 文本框中，点击 Add ssh key 就行。\n在 windows 系统上，你需要在你的博客文件夹中使用鼠标右键打开 GitBashHere，再输入跟上面一样的命令就行，有点不同的事你需要自己找到生成的密钥文件，在 生成密钥时会有提示，找到那个文件然后复制里面的内容就行。\n\n推送博客文件\n使用hexo clean清理一下 hexo 文件，hexo g重新生成网页，hexo d推送到远端。成功之后输入你的博客库名字就能访问了。\n\n\n\n\n完成之后​\t几个上面的操作，你应该已经拥有了一个自己的博客网站，当然这个网站还很简陋，你可以找一个喜欢的主题，或者去购买一个域名，这样就可以使用你的域名来访问你的博客网站。\n​\t到这里，这篇如何从零开始搭建自己的博客也就结束了，希望能够帮助到你🥳\n","slug":"从零开始搭建个人博客","date":"2023-11-05T06:50:10.000Z","categories_index":"教程","tags_index":"博客","author_index":"Mesonsaber"},{"id":"70c0c770528c6f3eab2585436d750f40","title":"JavaScript事件对象","content":"事件对象什么是事件对象\n也是一个对象，对象中有事件触发时的相关信息\n例如：鼠标点击事件中，事件对象就存放了鼠标点在了哪个位置等信息\n\n使用场景是什么\n可以判断用户按下哪个键，比如按下回车可以发布留言\n可以判断鼠标点击了哪个元素，从而做出相应的操作\n\n获取事件对象\n语法\n\n在事件绑定的回调函数的第一个参数就是事件对象\n\n1234Element.addEventListener(&#x27;click&#x27;, function(e)&#123;  //e就是事件对象  //可以使用e.方法名/属性名来使用事件对象&#125;)\n\n\n\n\n举个🌰\n\n12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button type=&quot;button&quot;&gt;点击&lt;/button&gt;    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt;    &lt;script&gt;        const input = document.querySelector(&#x27;input&#x27;)        input.addEventListener(&#x27;keyup&#x27;,function(e)&#123;            //使用key属性获取用户按的是哪个键            if(e.key === &#x27;Enter&#x27;)       //判断用户按下的是不是回车键            &#123;                console.log(&#x27;回车键按下&#x27;);            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n效果\n\n\n\n\n\n部分常用属性\n\ntype\n\n获取当前事件类型\n\n\nclientX&#x2F;clientY\n\n获取光标相对于浏览器可见窗口左上角的位置\n1console.log(e.clientX);\n\n\n\n\n\noffsetX&#x2F;offsetY\n\n获取光标相对于当前 DOM 元素左上角的位置\n1console.log(e.offsetX);\n\n\n\n\n\nkey\n\n用户按下的键盘键的值\n\n1console.log(e.key)\n\n\n\n\n\n\n案例实现按下回车发送消息\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;评论回车发布&lt;/title&gt;  &lt;style&gt;    .wrapper &#123;      min-width: 400px;      max-width: 800px;      display: flex;      justify-content: flex-end;    &#125;    .avatar &#123;      width: 48px;      height: 48px;      border-radius: 50%;      overflow: hidden;      background: url(./images/avatar.jpg) no-repeat center / cover;      margin-right: 20px;    &#125;    .wrapper textarea &#123;      outline: none;      border-color: transparent;      resize: none;      background: #f5f5f5;      border-radius: 4px;      flex: 1;      padding: 10px;      transition: all 0.5s;      height: 30px;    &#125;    .wrapper textarea:focus &#123;      border-color: #e4e4e4;      background: #fff;      height: 50px;    &#125;    .wrapper button &#123;      background: #00aeec;      color: #fff;      border: none;      border-radius: 4px;      margin-left: 10px;      width: 70px;      cursor: pointer;    &#125;    .wrapper .total &#123;      margin-right: 80px;      color: #999;      margin-top: 5px;      opacity: 0;      transition: all 0.5s;    &#125;    .list &#123;      min-width: 400px;      max-width: 800px;      display: flex;    &#125;    .list .item &#123;      width: 100%;      display: flex;    &#125;    .list .item .info &#123;      flex: 1;      border-bottom: 1px dashed #e4e4e4;      padding-bottom: 10px;    &#125;    .list .item p &#123;      margin: 0;    &#125;    .list .item .name &#123;      color: #FB7299;      font-size: 14px;      font-weight: bold;    &#125;    .list .item .text &#123;      color: #333;      padding: 10px 0;    &#125;    .list .item .time &#123;      color: #999;      font-size: 12px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;i class=&quot;avatar&quot;&gt;&lt;/i&gt;    &lt;textarea id=&quot;tx&quot; placeholder=&quot;发一条友善的评论&quot; rows=&quot;2&quot; maxlength=&quot;200&quot;&gt;&lt;/textarea&gt;    &lt;button&gt;发布&lt;/button&gt;  &lt;/div&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;span class=&quot;total&quot;&gt;0/200字&lt;/span&gt;  &lt;/div&gt;  &lt;div class=&quot;list&quot;&gt;    &lt;div class=&quot;item&quot; style=&quot;display: none;&quot;&gt;      &lt;i class=&quot;avatar&quot;&gt;&lt;/i&gt;      &lt;div class=&quot;info&quot;&gt;        &lt;p class=&quot;name&quot;&gt;清风徐来&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;大家都辛苦啦，感谢各位大大的努力，能圆满完成真是太好了[笑哭][支持]&lt;/p&gt;        &lt;p class=&quot;time&quot;&gt;2022-10-10 20:29:21&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    const tx = document.querySelector(&#x27;#tx&#x27;)    const total = document.querySelector(&#x27;.total&#x27;)    const item = document.querySelector(&#x27;.item&#x27;)    const text = document.querySelector(&#x27;.text&#x27;)    //当文本域获得焦点，将 total 显示出来    tx.addEventListener(&#x27;focus&#x27;, function()&#123;      total.style.opacity = 1    &#125;)    //失去焦点，就将 total 隐藏    tx.addEventListener(&#x27;blur&#x27;, function()&#123;      total.style.opacity = 0    &#125;)    //检测用户输入    tx.addEventListener(&#x27;input&#x27;, function()&#123;      total.innerHTML=`$&#123;tx.value.length&#125;/200字`    &#125;)    //绑定键盘事件    tx.addEventListener(&#x27;keyup&#x27;,function(e)&#123;      if(e.key===&#x27;Enter&#x27;)      &#123;        if(tx.value.trim()!==&#x27;&#x27;)      //判断输入是否为空        &#123;          item.style.display = &#x27;block&#x27;          text.innerHTML=tx.value        &#125;        tx.value=&#x27;&#x27;   //  清空文本域        total.innerHTML=&#x27;0/200字&#x27;     //恢复字符数量      &#125;          &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n效果\n\n以后就尝试把笔记上传到自己的博客上，不逼一下自己，这些东西容易忘\n","slug":"JavaScript事件对象","date":"2023-10-30T12:00:06.000Z","categories_index":"笔记","tags_index":"JavaScript","author_index":"Mesonsaber"},{"id":"3a720846f06b194cf852fdd1addeae93","title":"KMP匹配算法","content":"KMP匹配算法思路将待查询字符串 searchString 使用一串 next 数组表表示，当与源字符串 sourceString 匹配时，sourceString 不需要移动，只需要将 searchString 移动n位，然后再继续匹配，直到结束。\nnext 数组next 数组的值就是代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果 next[j]&#x3D;k，代表 j 之前的字符串中有最大长度为 k 的相同前缀后缀。\n至于为什么要求next 数组，等我们知道了 next 数组是怎么求的之后，再告诉大家\n那么如何来求 next 数组呢？\n如图：\n\n长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）\n长度为前2个字符的子串aa，最长相同前后缀的长度为1。\n长度为前3个字符的子串aab，最长相同前后缀的长度为0。\n以此类推：长度为前4个字符的子串aaba，最长相同前后缀的长度为1。长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。\n那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：\n可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n理解原理后，我们来用代码实现一下\n首先我们定义 getNext 函数\n1void getNext(char *p,int *next)\n\n\n初始化\n对相应的变量初始化\n\n\n12int j=0;next[0]=0;\t\t\t//第一个字符没有前后缀\n\n\n前后缀不相同情况\n1234567for(int i=0;i&lt;strlen(p);i++)&#123;  while(j&gt;0||p[i]!=p[j])  &#123;    j=next[j-1];  &#125;&#125;\n\n前后缀相同情况\n1234if(p[i]==p[j])&#123;  j++;&#125;\n\n更新 next 数组\n1next[i]=j;\n\n合并代码\n1234567891011121314151617void getNext(char *p,int *next)&#123;  int j=0;\tnext[0]=0;\t\t\t//第一个字符没有前后缀  for(int i=0;i&lt;strlen(p);i++)  &#123;    while(j&gt;0||p[i]!=p[j])    &#123;      j=next[j-1];    &#125;    if(p[i]==p[j])    &#123;      j++;    &#125;    next[i]=j;  &#125;&#125;\n\n相信大家通过代码更加理解了如何求 next 数组了。\n匹配通过以上对 next 数组的理解之后，我们再来KMP 算法是如何匹配的，我们已知，next 数组所代表的就是最大前缀后缀值，也就是说，在失配字符前，有多少个可重复的前缀后缀，这也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j-1] 的位置，也就是在失配字符之前已经重复出现过的前缀的后一个字符）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] &#x3D; k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。\n图例表示\n\n可以看到，当失配时，会跳到当前字符p[j]前一个字符p[j-1]的 next[j-1]值所指的字符，然后接着匹配，直至全部匹配到。\n我们可以简单的用代码表示\n1234567891011121314151617181920int kmp(char *s,char *t)&#123;  int j=0;  for(int i=0;i&lt;strlen(s);i++)  &#123;    if(j==0||s[i]==t[j])    &#123;      j++;    &#125;    else    &#123;      j=next[j-1];    &#125;  &#125;  if(j==strlen(t))  &#123;    return i-j;  &#125;  return -1;&#125;\n\n\n\n演示代码我们将两个函数合并，并运行一下程序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include&lt;string.h&gt;void getNext(char *p, int *next)&#123;    int j = 0;    next[0] = 0; // 第一个字符没有前后缀    for (int i = 1; i &lt; strlen(p); i++)    &#123;        while (j &gt; 0 &amp;&amp; p[i] != p[j])        &#123;            j = next[j - 1];        &#125;        if (p[i] == p[j])        &#123;            j++;        &#125;        next[i] = j;    &#125;&#125;int kmp(char s[], char t[])&#123;    int j = 0;    int n = strlen(t);    int next[n];    getNext(t, next);    for (int i = 0; i &lt; strlen(s); i++)    &#123;        while (j &gt; 0 &amp;&amp; s[i] != t[j])        &#123;            j = next[j - 1];        &#125;        if(s[i]==t[j])        &#123;            j++;        &#125;        if (j == strlen(t))        &#123;            return i - j+1;        &#125;    &#125;    return -1;&#125;int main()&#123;    char s[10];    scanf(&quot;%s&quot;,s);    char t[10];    scanf(&quot;%s&quot;,t);    getchar();    printf(&quot;%d\\n&quot;, kmp(s, t) + 1);    return 0;&#125;\n\n\n\n结果\n\n\n正确输出结果，abac 在 ababac 中第一次出现未知是 3。\n总结KMP 算法对于初学者来说确实会有些迷惑，但是只要理解了核心思想，现在看来也还是蛮简单的对吧。希望这对你学习 KMP 算法有所帮助\n部分内容来自 代码随想录 \n","slug":"KMP匹配算法","date":"2023-10-29T10:09:30.000Z","categories_index":"笔记","tags_index":"算法,数据结构,C 语言","author_index":"Mesonsaber"}]